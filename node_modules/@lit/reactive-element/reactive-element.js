import{getCompatibleStyle as t,adoptStyles as s}from"./css-tag.js";export{CSSResult,adoptStyles,css,getCompatibleStyle,supportsAdoptingStyleSheets,unsafeCSS}from"./css-tag.js";
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */window.JSCompiler_renameProperty=(t,s)=>t;const i={toAttribute(t,s){switch(s){case Boolean:t=t?"":null;break;case Object:case Array:t=null==t?t:JSON.stringify(t)}return t},fromAttribute(t,s){let i=t;switch(s){case Boolean:i=null!==t;break;case Number:i=null===t?null:Number(t);break;case Object:case Array:try{i=JSON.parse(t)}catch(t){i=null}}return i}},e=(t,s)=>s!==t&&(s==s||t==t),h={attribute:!0,type:String,converter:i,reflect:!1,hasChanged:e};class r extends HTMLElement{constructor(){super(),this.Πi=new Map,this.Πo=void 0,this.Πh=void 0,this.isUpdatePending=!1,this.hasUpdated=!1,this.Πl=null,this.Πu=new Promise((t=>this.enableUpdating=t)),this.Πp=new Map,this.Πm(),this.requestUpdate()}static get observedAttributes(){this.finalize();const t=[];return this.elementProperties.forEach(((s,i)=>{const e=this.Πv(i,s);void 0!==e&&(this.Πg.set(e,i),t.push(e))})),t}static createProperty(t,s=h){if(s.state&&(s.attribute=!1),this.finalize(),this.elementProperties.set(t,s),!s.noAccessor&&!this.prototype.hasOwnProperty(t)){const i="symbol"==typeof t?Symbol():"__"+t,e=this.getPropertyDescriptor(t,i,s);void 0!==e&&Object.defineProperty(this.prototype,t,e)}}static getPropertyDescriptor(t,s,i){return{get(){return this[s]},set(e){const h=this[t];this[s]=e,this.requestUpdate(t,h,i)},configurable:!0,enumerable:!0}}static getPropertyOptions(t){return this.elementProperties.get(t)||h}static finalize(){if(this.hasOwnProperty("finalized"))return!1;this.finalized=!0;const t=Object.getPrototypeOf(this);if(t.finalize(),this.elementProperties=new Map(t.elementProperties),this.Πg=new Map,this.hasOwnProperty(JSCompiler_renameProperty("properties",this))){const t=this.properties,s=[...Object.getOwnPropertyNames(t),...Object.getOwnPropertySymbols(t)];for(const i of s)this.createProperty(i,t[i])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(s){const i=[];if(Array.isArray(s)){const e=new Set(s.flat(1/0).reverse());for(const s of e)i.unshift(t(s))}else void 0!==s&&i.push(t(s));return i}static Πv(t,s){const i=s.attribute;return!1===i?void 0:"string"==typeof i?i:"string"==typeof t?t.toLowerCase():void 0}addController(t){(this.Π_??(this.Π_=[])).push(t)}Πm(){this.constructor.elementProperties.forEach(((t,s)=>{this.hasOwnProperty(s)&&(this.Πi.set(s,this[s]),delete this[s])}))}createRenderRoot(){const t=this.shadowRoot??this.attachShadow(this.constructor.shadowRootOptions);return s(t,this.constructor.elementStyles),t}connectedCallback(){this.hasUpdated||(this.renderRoot=this.createRenderRoot()),this.enableUpdating(),this.Π_?.forEach((t=>t.connectedCallback?.())),this.Πh&&(this.Πh(),this.Πo=this.Πh=void 0)}enableUpdating(){}disconnectedCallback(){this.Π_?.forEach((t=>t.disconnectedCallback?.())),this.Πo=new Promise((t=>this.Πh=t))}attributeChangedCallback(t,s,i){this.O(t,i)}ΠU(t,s,e=h){const r=this.constructor.Πv(t,e);if(void 0!==r&&!0===e.reflect){const h=(e.converter?.toAttribute??i.toAttribute)(s,e.type);this.Πl=t,null==h?this.removeAttribute(r):this.setAttribute(r,h),this.Πl=null}}O(t,s){const e=this.constructor,h=e.Πg.get(t);if(void 0!==h&&this.Πl!==h){const t=e.getPropertyOptions(h),r=t.converter,o=r?.fromAttribute??("function"==typeof r?r:null)??i.fromAttribute;this.Πl=h,this[h]=o(s,t.type),this.Πl=null}}requestUpdate(t,s,i){let h=!0;void 0!==t&&(((i=i||this.constructor.getPropertyOptions(t)).hasChanged||e)(this[t],s)?(this.Πp.has(t)||this.Πp.set(t,s),!0===i.reflect&&this.Πl!==t&&(void 0===this.Πj&&(this.Πj=new Map),this.Πj.set(t,i))):h=!1),!this.isUpdatePending&&h&&(this.Πu=this.Πk())}async Πk(){this.isUpdatePending=!0;try{for(await this.Πu;this.Πo;)await this.Πo}catch(t){Promise.reject(t)}const t=this.performUpdate();return null!=t&&await t,!this.isUpdatePending}performUpdate(){if(!this.isUpdatePending)return;this.hasUpdated,this.Πi&&(this.Πi.forEach(((t,s)=>this[s]=t)),this.Πi=void 0);let t=!1;const s=this.Πp;try{t=this.shouldUpdate(s),t?(this.Π_?.forEach((t=>t.willUpdate?.())),this.willUpdate(s),this.Π_?.forEach((t=>t.update?.())),this.update(s)):this.Πq()}catch(s){throw t=!1,this.Πq(),s}t&&this.H(s)}willUpdate(t){}H(t){this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(t)),this.Π_?.forEach((t=>t.updated?.())),this.updated(t)}Πq(){this.Πp=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this.Πu}shouldUpdate(t){return!0}update(t){void 0!==this.Πj&&(this.Πj.forEach(((t,s)=>this.ΠU(s,this[s],t))),this.Πj=void 0),this.Πq()}updated(t){}firstUpdated(t){}}r.finalized=!0,r.shadowRootOptions={mode:"open"},globalThis.reactiveElementPlatformSupport?.({ReactiveElement:r}),(window.reactiveElementVersions||(window.reactiveElementVersions=[])).push("1.0.0-pre.1");export{r as ReactiveElement,i as defaultConverter,e as notEqual};
//# sourceMappingURL=reactive-element.js.map
