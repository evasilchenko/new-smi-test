{"version":3,"file":"platform-support.js","sources":["../reactive-element/src/platform-support.ts","../lit-html/src/platform-support.ts","src/platform-support.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * ReactiveElement patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill, but\n * support for Shadow DOM like css scoping is opt-in. This module uses ShadyCSS\n * to scope styles defined via the `static styles` property.\n *\n * @packageDocumentation\n */\n\nconst needsPlatformSupport = !!(\n  window.ShadyCSS !== undefined &&\n  (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)\n);\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\nconst SCOPED = '__scoped';\n\ntype CSSResults = Array<{cssText: string} | CSSStyleSheet>;\n\ninterface PatchableReactiveElementConstructor {\n  [SCOPED]: boolean;\n  elementStyles: CSSResults;\n  shadowRootOptions: ShadowRootInit;\n  _$handlesPrepareStyles?: boolean;\n}\n\ninterface PatchableReactiveElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableReactiveElement;\n  constructor: PatchableReactiveElementConstructor;\n  connectedCallback(): void;\n  hasUpdated: boolean;\n  _$didUpdate(changedProperties: unknown): void;\n  createRenderRoot(): Element | ShadowRoot;\n  _$renderOptions: RenderOptions;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['reactiveElementPlatformSupport'] ??= ({\n  ReactiveElement,\n}: {\n  ReactiveElement: PatchableReactiveElement;\n}) => {\n  if (!needsPlatformSupport) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making ReactiveElement compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const elementProto = ReactiveElement.prototype;\n\n  /**\n   * Patch to apply adoptedStyleSheets via ShadyCSS\n   */\n  const createRenderRoot = elementProto.createRenderRoot;\n  elementProto.createRenderRoot = function (this: PatchableReactiveElement) {\n    // Pass the scope to render options so that it gets to lit-html for proper\n    // scoping via ShadyCSS.\n    const name = this.localName;\n    // If using native Shadow DOM must adoptStyles normally,\n    // otherwise do nothing.\n    if (window.ShadyCSS!.nativeShadow) {\n      return createRenderRoot.call(this);\n    } else {\n      if (!this.constructor.hasOwnProperty(SCOPED)) {\n        (this.constructor as PatchableReactiveElementConstructor)[\n          SCOPED\n        ] = true;\n        // Use ShadyCSS's `prepareAdoptedCssText` to shim adoptedStyleSheets.\n        const css = (this\n          .constructor as PatchableReactiveElementConstructor).elementStyles.map(\n          (v) =>\n            v instanceof CSSStyleSheet\n              ? Array.from(v.cssRules).reduce(\n                  (a: string, r: CSSRule) => (a += r.cssText),\n                  ''\n                )\n              : v.cssText\n        );\n        window.ShadyCSS?.ScopingShim?.prepareAdoptedCssText(css, name);\n        if (this.constructor._$handlesPrepareStyles === undefined) {\n          window.ShadyCSS!.prepareTemplateStyles(\n            document.createElement('template'),\n            name\n          );\n        }\n      }\n      return (\n        this.shadowRoot ??\n        this.attachShadow(\n          (this.constructor as PatchableReactiveElementConstructor)\n            .shadowRootOptions\n        )\n      );\n    }\n  };\n\n  /**\n   * Patch connectedCallback to apply ShadyCSS custom properties shimming.\n   */\n  const connectedCallback = elementProto.connectedCallback;\n  elementProto.connectedCallback = function (this: PatchableReactiveElement) {\n    connectedCallback.call(this);\n    // Note, must do first update separately so that we're ensured\n    // that rendering has completed before calling this.\n    if (this.hasUpdated) {\n      window.ShadyCSS!.styleElement(this);\n    }\n  };\n\n  /**\n   * Patch update to apply ShadyCSS custom properties shimming for first\n   * update.\n   */\n  const didUpdate = elementProto._$didUpdate;\n  elementProto._$didUpdate = function (\n    this: PatchableReactiveElement,\n    changedProperties: unknown\n  ) {\n    const isFirstUpdate = !this.hasUpdated;\n    didUpdate.call(this, changedProperties);\n    // Note, must do first update here so rendering has completed before\n    // calling this and styles are correct by updated/firstUpdated.\n    if (isFirstUpdate) {\n      window.ShadyCSS!.styleElement(this);\n    }\n  };\n};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * lit-html patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill.\n * Scoping classes are added to DOM nodes to facilitate CSS scoping that\n * simulates the style scoping Shadow DOM provides. ShadyDOM does this scoping\n * to all elements added to the DOM. This module provides an important\n * optimization for this process by pre-scoping lit-html template\n * DOM. This means ShadyDOM does not have to scope each instance of the\n * template DOM. Instead, each template is scoped only once.\n *\n * Creating scoped CSS is not covered by this module. It is, however, integrated\n * into the lit-element and @lit/reactive-element packages. See the ShadyCSS docs\n * for how to apply scoping to CSS:\n * https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#usage.\n *\n * @packageDocumentation\n */\n\nconst needsPlatformSupport = !!(\n  window.ShadyCSS !== undefined &&\n  (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)\n);\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface ShadyTemplateResult {\n  strings: TemplateStringsArray;\n  _$litType$?: string;\n}\n\ninterface PatchableChildPart {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableChildPart;\n  _$committedValue: unknown;\n  _$startNode: ChildNode;\n  _$endNode: ChildNode | null;\n  options: RenderOptions;\n  _$setValue(value: unknown): void;\n  _$getTemplate(\n    strings: TemplateStringsArray,\n    result: ShadyTemplateResult\n  ): HTMLTemplateElement;\n}\n\ninterface PatchableTemplate {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableTemplate;\n  _$createElement(html: string): HTMLTemplateElement;\n  _$element: HTMLTemplateElement;\n  _$options: RenderOptions;\n}\n\ninterface PatchableTemplateInstance {\n  _$template: PatchableTemplate;\n}\n\n// Scopes that have had styling prepared. Note, must only be done once per\n// scope.\nconst styledScopes: Set<string> = new Set();\n// Map of css per scope. This is collected during first scope render, used when\n// styling is prepared, and then discarded.\nconst scopeCssStore: Map<string, string[]> = new Map();\n\n/**\n * lit-html patches. These properties cannot be renamed.\n * * ChildPart.prototype._$getTemplate\n * * ChildPart.prototype._$setValue\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport'] ??= (\n  Template: PatchableTemplate,\n  ChildPart: PatchableChildPart\n) => {\n  if (!needsPlatformSupport) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making lit-html compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const needsPrepareStyles = (name: string | undefined) =>\n    name !== undefined && !styledScopes.has(name);\n\n  const cssForScope = (name: string) => {\n    let scopeCss = scopeCssStore.get(name);\n    if (scopeCss === undefined) {\n      scopeCssStore.set(name, (scopeCss = []));\n    }\n    return scopeCss;\n  };\n\n  const prepareStyles = (name: string, template: HTMLTemplateElement) => {\n    // Get styles\n    const scopeCss = cssForScope(name);\n    if (scopeCss.length) {\n      const style = document.createElement('style');\n      style.textContent = scopeCss.join('\\n');\n      // Note, it's important to add the style to the *end* of the template so\n      // it doesn't mess up part indices.\n      template.content.appendChild(style);\n    }\n    // Mark this scope as styled.\n    styledScopes.add(name);\n    // Remove stored data since it's no longer needed.\n    scopeCssStore.delete(name);\n    // ShadyCSS removes scopes and removes the style under ShadyDOM and leaves\n    // it under native Shadow DOM\n    window.ShadyCSS!.prepareTemplateStyles(template, name);\n  };\n\n  const scopedTemplateCache = new Map<\n    string,\n    Map<TemplateStringsArray, PatchableTemplate>\n  >();\n\n  // Note, it's ok to subclass Template since it's only used via ChildPart.\n  class ShadyTemplate extends Template {\n    /**\n     * Override to extract style elements from the template\n     * and store all style.textContent in the shady scope data.\n     */\n    _$createElement(html: string) {\n      const template = super._$createElement(html);\n      const scope = this._$options?.scope;\n      if (scope !== undefined) {\n        if (!window.ShadyCSS!.nativeShadow) {\n          window.ShadyCSS!.prepareTemplateDom(template, scope);\n        }\n        const scopeCss = cssForScope(scope);\n        // Remove styles and store textContent.\n        const styles = template.content.querySelectorAll(\n          'style'\n        ) as NodeListOf<HTMLStyleElement>;\n        // Store the css in this template in the scope css and remove the <style>\n        // from the template _before_ the node-walk captures part indices\n        scopeCss.push(\n          ...Array.from(styles).map((style) => {\n            style.parentNode?.removeChild(style);\n            return style.textContent!;\n          })\n        );\n      }\n      return template;\n    }\n  }\n\n  const renderContainer = document.createDocumentFragment();\n  const renderContainerMarker = document.createComment('');\n\n  const childPartProto = ChildPart.prototype;\n  /**\n   * Patch to apply gathered css via ShadyCSS. This is done only once per scope.\n   */\n  const setValue = childPartProto._$setValue;\n  childPartProto._$setValue = function (\n    this: PatchableChildPart,\n    value: unknown\n  ) {\n    const container = this._$startNode.parentNode!;\n    const scope = this.options.scope;\n    if (container instanceof ShadowRoot && needsPrepareStyles(scope)) {\n      // Note, @apply requires outer => inner scope rendering on initial\n      // scope renders to apply property values correctly. Style preparation\n      // is tied to rendering into `shadowRoot`'s and this is typically done by\n      // custom elements. If this is done in `connectedCallback`, as is typical,\n      // the code below ensures the right order since content is rendered\n      // into a fragment first so the hosting element can prepare styles first.\n      // If rendering is done in the constructor, this won't work, but that's\n      // not supported in ShadyDOM anyway.\n      const startNode = this._$startNode;\n      const endNode = this._$endNode;\n\n      // Temporarily move this part into the renderContainer.\n      renderContainer.appendChild(renderContainerMarker);\n      this._$startNode = renderContainerMarker;\n      this._$endNode = null;\n\n      // Note, any nested template results render here and their styles will\n      // be extracted and collected.\n      setValue.call(this, value);\n\n      // Get the template for this result or create a dummy one if a result\n      // is not being rendered.\n      const template = (value as ShadyTemplateResult)?._$litType$\n        ? (this._$committedValue as PatchableTemplateInstance)._$template\n            ._$element\n        : document.createElement('template');\n      prepareStyles(scope!, template);\n\n      // Note, this is the temporary startNode.\n      renderContainer.removeChild(renderContainerMarker);\n      // When using native Shadow DOM, include prepared style in shadowRoot.\n      if (window.ShadyCSS?.nativeShadow) {\n        const style = template.content.querySelector('style');\n        if (style !== null) {\n          renderContainer.appendChild(style.cloneNode(true));\n        }\n      }\n      container.insertBefore(renderContainer, endNode);\n      // Move part back to original container.\n      this._$startNode = startNode;\n      this._$endNode = endNode;\n    } else {\n      setValue.call(this, value);\n    }\n  };\n\n  /**\n   * Patch ChildPart._$getTemplate to look up templates in a cache bucketed\n   * by element name.\n   */\n  childPartProto._$getTemplate = function (\n    strings: TemplateStringsArray,\n    result: ShadyTemplateResult\n  ) {\n    const scope = this.options.scope!;\n    let templateCache = scopedTemplateCache.get(scope);\n    if (templateCache === undefined) {\n      scopedTemplateCache.set(scope, (templateCache = new Map()));\n    }\n    let template = templateCache.get(strings);\n    if (template === undefined) {\n      templateCache.set(\n        strings,\n        (template = new ShadyTemplate(result, this.options))\n      );\n    }\n    return template;\n  };\n};\n","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * LitElement patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill, but\n * support for Shadow DOM like css scoping is opt-in. This module uses ShadyCSS\n * to scope styles defined via the `static styles` property and styles included\n * in the render method. There are some limitations to be aware of:\n * * only styles that are included in the first render of a component are scoped.\n * * In addition, support for the deprecated `@apply` feature of ShadyCSS is\n * only provided for styles included in the template and not styles provided\n * via the static styles property.\n * * Lit parts cannot be used in styles included in the template.\n *\n * @packageDocumentation\n */\n\nimport '@lit/reactive-element/platform-support.js';\nimport 'lit-html/platform-support.js';\n\nconst needsPlatformSupport = !!(\n  window.ShadyCSS !== undefined &&\n  (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)\n);\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface PatchableLitElementConstructor {\n  _$handlesPrepareStyles?: boolean;\n}\n\ninterface PatchableLitElement extends HTMLElement {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableLitElement;\n  constructor: PatchableLitElementConstructor;\n  createRenderRoot(): Element | ShadowRoot;\n  _$renderOptions: RenderOptions;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litElementPlatformSupport'] ??= ({\n  LitElement,\n}: {\n  LitElement: PatchableLitElement;\n}) => {\n  if (!needsPlatformSupport) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making LitElement compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  ((LitElement as unknown) as PatchableLitElementConstructor)._$handlesPrepareStyles = true;\n\n  /**\n   * Patch to apply adoptedStyleSheets via ShadyCSS\n   */\n  const litElementProto = LitElement.prototype;\n  const createRenderRoot = litElementProto.createRenderRoot;\n  litElementProto.createRenderRoot = function (this: PatchableLitElement) {\n    // Pass the scope to render options so that it gets to lit-html for proper\n    // scoping via ShadyCSS. This is needed under Shady and also Shadow DOM,\n    // due to @apply.\n    this._$renderOptions.scope = this.localName;\n    return createRenderRoot.call(this);\n  };\n};\n"],"names":["needsPlatformSupport","window","ShadyCSS","nativeShadow","ApplyShim","SCOPED","globalThis","reactiveElementPlatformSupport","ReactiveElement","elementProto","prototype","createRenderRoot","name","this","localName","call","constructor","hasOwnProperty","css","elementStyles","map","v","CSSStyleSheet","Array","from","cssRules","reduce","a","r","cssText","ScopingShim","prepareAdoptedCssText","_$handlesPrepareStyles","prepareTemplateStyles","document","createElement","shadowRoot","attachShadow","shadowRootOptions","connectedCallback","hasUpdated","styleElement","didUpdate","_$didUpdate","changedProperties","isFirstUpdate","styledScopes","Set","scopeCssStore","Map","litHtmlPlatformSupport","Template","ChildPart","cssForScope","scopeCss","get","set","scopedTemplateCache","ShadyTemplate","[object Object]","html","template","super","_$createElement","scope","_$options","prepareTemplateDom","styles","content","querySelectorAll","push","style","parentNode","removeChild","textContent","renderContainer","createDocumentFragment","renderContainerMarker","createComment","childPartProto","setValue","_$setValue","value","container","_$startNode","options","ShadowRoot","has","startNode","endNode","_$endNode","appendChild","_$litType$","_$committedValue","_$template","_$element","length","join","add","delete","querySelector","cloneNode","insertBefore","_$getTemplate","strings","result","templateCache","undefined","LitElement","litElementProto","_$renderOptions"],"mappings":"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"}