/**
 * @license
 * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import { ChildPart, Part, DirectiveParent, TemplateResult } from './lit-html.js';
import { DirectiveResult, DirectiveClass, PartInfo } from './directive.js';
/**
 * Tests if a value is a primitive value.
 *
 * See https://tc39.github.io/ecma262/#sec-typeof-operator
 */
export declare const isPrimitive: (value: unknown) => value is string | number | bigint | boolean | symbol | null | undefined;
export declare const TemplateResultType: {
    readonly HTML: 1;
    readonly SVG: 2;
};
export declare type TemplateResultType = typeof TemplateResultType[keyof typeof TemplateResultType];
/**
 * Tests if a value is a TemplateResult.
 */
export declare const isTemplateResult: (value: unknown, type?: 2 | 1 | undefined) => value is TemplateResult;
/**
 * Tests if a value is a DirectiveResult.
 */
export declare const isDirectiveResult: (value: unknown, klass?: DirectiveClass | undefined) => value is DirectiveResult<DirectiveClass>;
/**
 * Tests whether a part has only a single-expression with no strings to
 * interpolate between.
 *
 * Only AttributePart and PropertyPart can have multiple expressions.
 * Multi-expression parts have a `strings` property and single-expression
 * parts do not.
 */
export declare const isSingleExpression: (part: PartInfo) => boolean;
/**
 * Inserts a ChildPart into the given container ChildPart's DOM, either at the
 * end of the container ChildPart, or before the optional `refPart`.
 *
 * This does not add the part to the containerPart's comitted value. That must
 * be done by callers.
 *
 * @param containerPart Part within which to add the new ChildPart
 * @param refPart Part before which to add the new ChildPart; when omitted the
 *     part added to the end of the `containerPart`
 * @param part Part to insert, or undefined to create a new part
 */
export declare const insertPart: (containerPart: ChildPart, refPart: ChildPart | undefined, part?: {
    readonly type: 2;
    readonly options: import("./lit-html.js").RenderOptions | undefined;
    _$committedValue: unknown;
    __directive?: import("./directive.js").Directive | undefined;
    _$startNode: ChildNode;
    _$endNode: ChildNode | null;
    _$parent: import("./lit-html.js").Disconnectable | undefined;
    _$disconnetableChildren?: Set<import("./lit-html.js").Disconnectable> | undefined;
    _$setChildPartConnected?: ((isConnected: boolean, removeFromParent?: boolean | undefined, from?: number | undefined) => void) | undefined;
    setConnected: (isConnected: boolean) => void;
    readonly parentNode: Node;
    _$setValue: (value: unknown, directiveParent?: DirectiveParent) => void;
    _$getTemplate: (strings: TemplateStringsArray, result: TemplateResult) => {
        _$element: HTMLTemplateElement;
        _parts: ({
            readonly _type: 2;
            readonly _index: number;
        } | {
            readonly _type: 1;
            readonly _index: number;
            readonly _name: string;
            readonly _constructor: new (element: HTMLElement, name: string, strings: readonly string[], parent: import("./lit-html.js").Disconnectable | undefined, options: import("./lit-html.js").RenderOptions | undefined) => {
                readonly type: 1 | 5 | 4 | 3;
                readonly element: HTMLElement;
                readonly name: string;
                readonly options: import("./lit-html.js").RenderOptions | undefined;
                readonly strings?: readonly string[] | undefined;
                _$committedValue: unknown;
                __directives?: (import("./directive.js").Directive | undefined)[] | undefined;
                _$parent: import("./lit-html.js").Disconnectable | undefined;
                _$disconnetableChildren?: Set<import("./lit-html.js").Disconnectable> | undefined;
                _setDirectiveConnected?: ((directive: import("./directive.js").Directive | undefined, isConnected: boolean, removeFromParent?: boolean | undefined) => void) | undefined;
                readonly tagName: string;
                _$setValue: (value: unknown, directiveParent?: DirectiveParent, valueIndex?: number | undefined, noCommit?: boolean | undefined) => void;
                _commitValue: (value: unknown) => void;
            };
            readonly _strings: readonly string[];
        } | {
            readonly _type: 6;
            readonly _index: number;
        } | {
            readonly _type: 7;
            readonly _index: number;
        })[];
        _$options?: import("./lit-html.js").RenderOptions | undefined;
        _$createElement: (html: string) => HTMLTemplateElement;
    };
    _$clear: (start?: ChildNode | null, from?: number | undefined) => void;
} | undefined) => ChildPart;
/**
 * Sets the value of a Part.
 *
 * Note that this should only be used to set/update the value of user-created
 * parts (i.e. those created using `insertPart`); it should not be used
 * by directives to set the value of the directive's container part. Directives
 * should return a value from `update`/`render` to update their part state.
 *
 * For directives that require setting their part value asynchronously, they
 * should extend `DisconnectableDirective` and call `this.setValue()`.
 *
 * @param part Part to set
 * @param value Value to set
 * @param index For `AttributePart`s, the index to set
 * @param directiveParent Used internally; should not be set by user
 */
export declare const setChildPartValue: <T extends {
    readonly type: 2;
    readonly options: import("./lit-html.js").RenderOptions | undefined;
    _$committedValue: unknown;
    __directive?: import("./directive.js").Directive | undefined;
    _$startNode: ChildNode;
    _$endNode: ChildNode | null;
    _$parent: import("./lit-html.js").Disconnectable | undefined;
    _$disconnetableChildren?: Set<import("./lit-html.js").Disconnectable> | undefined;
    _$setChildPartConnected?: ((isConnected: boolean, removeFromParent?: boolean | undefined, from?: number | undefined) => void) | undefined;
    setConnected: (isConnected: boolean) => void;
    readonly parentNode: Node;
    _$setValue: (value: unknown, directiveParent?: DirectiveParent) => void;
    _$getTemplate: (strings: TemplateStringsArray, result: TemplateResult) => {
        _$element: HTMLTemplateElement;
        _parts: ({
            readonly _type: 2;
            readonly _index: number;
        } | {
            readonly _type: 1;
            readonly _index: number;
            readonly _name: string;
            readonly _constructor: new (element: HTMLElement, name: string, strings: readonly string[], parent: import("./lit-html.js").Disconnectable | undefined, options: import("./lit-html.js").RenderOptions | undefined) => {
                readonly type: 1 | 5 | 4 | 3;
                readonly element: HTMLElement;
                readonly name: string;
                readonly options: import("./lit-html.js").RenderOptions | undefined;
                readonly strings?: readonly string[] | undefined;
                _$committedValue: unknown;
                __directives?: (import("./directive.js").Directive | undefined)[] | undefined;
                _$parent: import("./lit-html.js").Disconnectable | undefined;
                _$disconnetableChildren?: Set<import("./lit-html.js").Disconnectable> | undefined;
                _setDirectiveConnected?: ((directive: import("./directive.js").Directive | undefined, isConnected: boolean, removeFromParent?: boolean | undefined) => void) | undefined;
                readonly tagName: string;
                _$setValue: (value: unknown, directiveParent?: DirectiveParent, valueIndex?: number | undefined, noCommit?: boolean | undefined) => void;
                _commitValue: (value: unknown) => void;
            };
            readonly _strings: readonly string[];
        } | {
            readonly _type: 6;
            readonly _index: number;
        } | {
            readonly _type: 7;
            readonly _index: number;
        })[];
        _$options?: import("./lit-html.js").RenderOptions | undefined;
        _$createElement: (html: string) => HTMLTemplateElement;
    };
    _$clear: (start?: ChildNode | null, from?: number | undefined) => void;
}>(part: T, value: unknown, directiveParent?: DirectiveParent) => T;
/**
 * Sets the committed value of a ChildPart directly without triggering the
 * commit stage of the part.
 *
 * This is useful in cases where a directive needs to update the part such
 * that the next update detects a value change or not. When value is omitted,
 * the next update will be guaranteed to be detected as a change.
 *
 * @param part
 * @param value
 */
export declare const setComittedValue: (part: Part, value?: unknown) => unknown;
/**
 * Returns the committed value of a ChildPart.
 *
 * The committed value is used for change detection and efficient updates of
 * the part. It can differ from the value set by the template or directive in
 * cases where the template value is transformed before being commited.
 *
 * - `TemplateResult`s are committed as a `TemplateInstance`
 * - Iterables are committed as `Array<ChildPart>`
 * - All other types are committed as the template value or value returned or
 *   set by a directive.
 *
 * @param part
 */
export declare const getComittedValue: (part: ChildPart) => unknown;
/**
 * Removes a ChildPart from the DOM, including any of its content.
 *
 * @param part The Part to remove
 */
export declare const removePart: (part: ChildPart) => void;
export declare const clearPart: (part: ChildPart) => void;
//# sourceMappingURL=directive-helpers.d.ts.map