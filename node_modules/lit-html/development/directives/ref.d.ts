/**
 * @license
 * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import { ElementPart } from '../lit-html.js';
import { DisconnectableDirective } from '../disconnectable-directive.js';
/**
 * Creates a new Ref object, which is container for a reference to an element.
 */
export declare const createRef: <T = Element>() => Ref<T>;
declare class Ref<T = Element> {
    /**
     * The current Element value of the ref, or else `undefined` if the ref is no
     * longer rendered.
     */
    readonly value?: T;
}
export declare type RefOrCallback = Ref | ((el: Element | undefined) => void);
declare class RefDirective extends DisconnectableDirective {
    private _element?;
    private _ref?;
    render(_ref: RefOrCallback): symbol;
    update(part: ElementPart, [ref]: Parameters<this['render']>): symbol;
    private _updateRefValue;
    private get _lastElementForRef();
    disconnectedCallback(): void;
    reconnectedCallback(): void;
}
/**
 * Sets the value of a Ref object or calls a ref callback with the element it's
 * bound to.
 *
 * A Ref object acts as a container for a reference to an element. A ref
 * callback is a function that takes an element as its only argument.
 *
 * The ref directive sets the value of the Ref object or calls the ref callback
 * during rendering, if the referenced element changed.
 *
 * Note: If a ref callback is rendered to a different element position or is
 * removed in a subsequent render, it will first be called with `undefined`,
 * followed by another call with the new element it was rendered to (if any).
 *
 * @example
 *
 *    // Using Ref object
 *    const inputRef = createRef();
 *    render(html`<input ${ref(inputRef)}>`, container);
 *    inputRef.value.focus();
 *
 *    // Using callback
 *    const callback = (inputElement) => inputElement.focus();
 *    render(html`<input ${ref(callback)}>`, container);
 */
export declare const ref: (_ref: RefOrCallback) => import("../directive.js").DirectiveResult<typeof RefDirective>;
export {};
//# sourceMappingURL=ref.d.ts.map