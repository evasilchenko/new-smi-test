{"version":3,"file":"ref.js","sourceRoot":"","sources":["../../src/directives/ref.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AACH,OAAO,EAAC,OAAO,EAAc,MAAM,gBAAgB,CAAC;AACpD,OAAO,EACL,SAAS,EACT,uBAAuB,GACxB,MAAM,gCAAgC,CAAC;AAExC;;GAEG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG,GAAgB,EAAE,CAAC,IAAI,GAAG,EAAK,CAAC;AAEzD,MAAM,GAAG;CAMR;AAMD,gFAAgF;AAChF,6EAA6E;AAC7E,0CAA0C;AAC1C,MAAM,sBAAsB,GAGxB,IAAI,OAAO,EAAE,CAAC;AAIlB,MAAM,YAAa,SAAQ,uBAAuB;IAIhD,MAAM,CAAC,IAAmB;QACxB,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,MAAM,CAAC,IAAiB,EAAE,CAAC,GAAG,CAA6B;QACzD,MAAM,UAAU,GAAG,GAAG,KAAK,IAAI,CAAC,IAAI,CAAC;QACrC,IAAI,UAAU,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,EAAE;YACzC,+CAA+C;YAC/C,iCAAiC;YACjC,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;SACjC;QACD,IAAI,UAAU,IAAI,IAAI,CAAC,kBAAkB,KAAK,IAAI,CAAC,QAAQ,EAAE;YAC3D,uDAAuD;YACvD,+CAA+C;YAC/C,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;YAChB,IAAI,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;SACtD;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,eAAe,CAAC,OAA4B;QAClD,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,EAAE;YACnC,iEAAiE;YACjE,yEAAyE;YACzE,qEAAqE;YACrE,wEAAwE;YACxE,wEAAwE;YACxE,oBAAoB;YACpB,IAAI,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE;gBACvD,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACtB;YACD,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YAC/C,0CAA0C;YAC1C,IAAI,OAAO,KAAK,SAAS,EAAE;gBACzB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACpB;SACF;aAAM;YACJ,IAAI,CAAC,IAAqB,CAAC,KAAK,GAAG,OAAO,CAAC;SAC7C;IACH,CAAC;IAED,IAAY,kBAAkB;QAC5B,OAAO,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU;YACpC,CAAC,CAAC,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;YACvC,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;IACvB,CAAC;IAED,oBAAoB;QAClB,yEAAyE;QACzE,wEAAwE;QACxE,2EAA2E;QAC3E,iBAAiB;QACjB,IAAI,IAAI,CAAC,kBAAkB,KAAK,IAAI,CAAC,QAAQ,EAAE;YAC7C,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;SACjC;IACH,CAAC;IAED,mBAAmB;QACjB,0EAA0E;QAC1E,sEAAsE;QACtE,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtC,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,MAAM,CAAC,MAAM,GAAG,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport {nothing, ElementPart} from '../lit-html.js';\nimport {\n  directive,\n  DisconnectableDirective,\n} from '../disconnectable-directive.js';\n\n/**\n * Creates a new Ref object, which is container for a reference to an element.\n */\nexport const createRef = <T = Element>() => new Ref<T>();\n\nclass Ref<T = Element> {\n  /**\n   * The current Element value of the ref, or else `undefined` if the ref is no\n   * longer rendered.\n   */\n  readonly value?: T;\n}\n\ninterface RefInternal {\n  value: Element | undefined;\n}\n\n// When callbacks are used for refs, this map tracks the last value the callback\n// was called with, for ensuring a directive doesn't clear the ref if the ref\n// has already been rendered to a new spot\nconst lastElementForCallback: WeakMap<\n  Function,\n  Element | undefined\n> = new WeakMap();\n\nexport type RefOrCallback = Ref | ((el: Element | undefined) => void);\n\nclass RefDirective extends DisconnectableDirective {\n  private _element?: Element;\n  private _ref?: RefOrCallback;\n\n  render(_ref: RefOrCallback) {\n    return nothing;\n  }\n\n  update(part: ElementPart, [ref]: Parameters<this['render']>) {\n    const refChanged = ref !== this._ref;\n    if (refChanged && this._ref !== undefined) {\n      // The ref passed to the directive has changed;\n      // unset the previous ref's value\n      this._updateRefValue(undefined);\n    }\n    if (refChanged || this._lastElementForRef !== this._element) {\n      // We either got a new ref or this is the first render;\n      // store the ref/element & update the ref value\n      this._ref = ref;\n      this._updateRefValue((this._element = part.element));\n    }\n    return nothing;\n  }\n\n  private _updateRefValue(element: Element | undefined) {\n    if (typeof this._ref === 'function') {\n      // If the current ref was called with a previous value, call with\n      // `undefined`; We do this to ensure callbacks are called in a consistent\n      // way regardless of whether a ref might be moving up in the tree (in\n      // which case it would otherwise be called with the new value before the\n      // previous one unsets it) and down in the tree (where it would be unset\n      // before being set)\n      if (lastElementForCallback.get(this._ref) !== undefined) {\n        this._ref(undefined);\n      }\n      lastElementForCallback.set(this._ref, element);\n      // Call the ref with the new element value\n      if (element !== undefined) {\n        this._ref(element);\n      }\n    } else {\n      (this._ref as RefInternal)!.value = element;\n    }\n  }\n\n  private get _lastElementForRef() {\n    return typeof this._ref === 'function'\n      ? lastElementForCallback.get(this._ref)\n      : this._ref?.value;\n  }\n\n  disconnectedCallback() {\n    // Only clear the box if our element is still the one in it (i.e. another\n    // directive instance hasn't rendered its element to it before us); that\n    // only happens in the event of the directive being cleared (not via manual\n    // disconnection)\n    if (this._lastElementForRef === this._element) {\n      this._updateRefValue(undefined);\n    }\n  }\n\n  reconnectedCallback() {\n    // If we were manually disconnected, we can safely put our element back in\n    // the box, since no rendering could have occurred to change its state\n    this._updateRefValue(this._element);\n  }\n}\n\n/**\n * Sets the value of a Ref object or calls a ref callback with the element it's\n * bound to.\n *\n * A Ref object acts as a container for a reference to an element. A ref\n * callback is a function that takes an element as its only argument.\n *\n * The ref directive sets the value of the Ref object or calls the ref callback\n * during rendering, if the referenced element changed.\n *\n * Note: If a ref callback is rendered to a different element position or is\n * removed in a subsequent render, it will first be called with `undefined`,\n * followed by another call with the new element it was rendered to (if any).\n *\n * @example\n *\n *    // Using Ref object\n *    const inputRef = createRef();\n *    render(html`<input ${ref(inputRef)}>`, container);\n *    inputRef.value.focus();\n *\n *    // Using callback\n *    const callback = (inputElement) => inputElement.focus();\n *    render(html`<input ${ref(callback)}>`, container);\n */\nexport const ref = directive(RefDirective);\n"]}