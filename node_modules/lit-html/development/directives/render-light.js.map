{"version":3,"file":"render-light.js","sourceRoot":"","sources":["../../src/directives/render-light.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;AAGH,OAAO,EAAC,SAAS,EAAE,SAAS,EAAC,MAAM,iBAAiB,CAAC;AACrD,OAAO,EAAC,iBAAiB,EAAC,MAAM,yBAAyB,CAAC;AAM1D,MAAM,WAAY,SAAQ,SAAS;IACjC,MAAM;QACJ,8CAA8C;IAChD,CAAC;IACD,MAAM,CAAC,IAAe;QACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,UAA6B,CAAC;QACpD,IAAI,OAAO,QAAQ,CAAC,WAAW,KAAK,UAAU,EAAE;YAC9C,OAAO,QAAQ,CAAC,WAAW,EAAE,CAAC;SAC/B;IACH,CAAC;CACF;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmFG;AACH,MAAM,CAAC,MAAM,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC,CAAC;AAElD,MAAM,CAAC,MAAM,sBAAsB,GAAG,CAAC,KAAc,EAAW,EAAE,CAChE,iBAAiB,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2019 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {ChildPart} from '../lit-html.js';\nimport {directive, Directive} from '../directive.js';\nimport {isDirectiveResult} from '../directive-helpers.js';\n\nexport interface RenderLightHost extends HTMLElement {\n  renderLight(): unknown;\n}\n\nclass RenderLight extends Directive {\n  render() {\n    /* SSR handled specially in render-lit-html */\n  }\n  update(part: ChildPart) {\n    const instance = part.parentNode as RenderLightHost;\n    if (typeof instance.renderLight === 'function') {\n      return instance.renderLight();\n    }\n  }\n}\n\n/**\n * This directive allows a host element to control its light DOM rendering in\n * addition to its shadow DOM rendering, by implementing a renderLight() method.\n *\n * Here's an example of a <x-story> element that intended to server and client\n * side render its light DOM, but only client-side render its shadow DOM.\n *\n * The light DOM will contain just content:\n *\n * ```html\n * <x-story>\n *   <h1>Hello World</h1>\n *   <p>This is a story about greeting the earth.</p>\n * </x-story>\n * ```\n *\n * On the client the shadow DOM renders as usually and contains the \"chrome\" or\n * the decoration and interactive elements:\n *\n * ```html\n * <x-story>\n *   #shadow-root\n *     <slot></slot>\n *     <button>Like></button>\n *   <h1>Hello World</h1>\n *   <p>This is a story about greeting the earth.</p>\n * </x-story>\n * ```\n *\n * Implementation (using `LitElement`):\n *\n * ```js\n * class StoryElement extends LitElement implements RenderLightHost {\n *\n *   @property() title;\n *   @property() body;\n *\n *   renderLight() {\n *     return html`\n *       <h1>${this.title}</h1>\n *       <p>${this.body}</p>\n *     `;\n *   }\n *\n *   render() {\n *     return html`\n *       <slot></slot>\n *       <button @client=${this.like}>Like</button>\n *     `\n *   }\n * }\n * ```\n *\n * To use the renderLight() method, the use-site of the element must opt into it\n * with the renderLight directive:\n *\n * ```js\n * const story = {\n *   title: 'Hello World',\n *   body: 'This is a story about greeting the earth.',\n * };\n *\n * const t = (story) => html`\n *     <x-story\n *         .title=${story.title}\n *         .body=${story.body}>\n *       ${renderLight()}\n *     </x-story>`\n * ```\n *\n * This prevents contention on the light DOM between the user of the component\n * and the component itself. The component doesn't actually render to its\n * light DOM, its user does. The component provides the implementation.\n *\n * The component will also need to provide its light DOM styling. This is TBD,\n * but obviously won't be able to take advantage of shadow DOM scoping.\n *\n * The major advantage of structuring SSR'ed components this way is that we can\n * render the critical content on the server so that it's indexable and\n * renderable without loading component definitions, but we don't bloat the HTML\n * payload with copies of the component implementation markup. Users who have\n * split light an shadow DOM rendering in a similar way have reported that it's\n * faster to first contentful paint than the \"deep\" SSR that is common place.\n */\nexport const renderLight = directive(RenderLight);\n\nexport const isRenderLightDirective = (value: unknown): boolean =>\n  isDirectiveResult(value, RenderLight);\n"]}