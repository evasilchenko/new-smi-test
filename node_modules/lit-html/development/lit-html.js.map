{"version":3,"file":"lit-html.js","sourceRoot":"","sources":["../src/lit-html.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;GAYG;;AAKH,MAAM,QAAQ,GAAG,IAAI,CAAC;AACtB,MAAM,2BAA2B,GAAG,IAAI,CAAC;AAEzC,IAAI,QAAQ,EAAE;IACZ,OAAO,CAAC,IAAI,CAAC,0DAA0D,CAAC,CAAC;CAC1E;AA0CD,MAAM,gBAAgB,GAAmB,CAAC,KAAc,EAAE,EAAE,CAAC,KAAK,CAAC;AACnE,MAAM,aAAa,GAAqB,CACtC,KAAW,EACX,KAAa,EACb,KAA+B,EAC/B,EAAE,CAAC,gBAAgB,CAAC;AAEtB,yCAAyC;AACzC,MAAM,YAAY,GAAG,CAAC,YAA8B,EAAE,EAAE;IACtD,IAAI,CAAC,2BAA2B,EAAE;QAChC,OAAO;KACR;IACD,IAAI,wBAAwB,KAAK,aAAa,EAAE;QAC9C,MAAM,IAAI,KAAK,CACb,2DAA2D;YACzD,4DAA4D,CAC/D,CAAC;KACH;IACD,wBAAwB,GAAG,YAAY,CAAC;AAC1C,CAAC,CAAC;AAEF;;GAEG;AACH,MAAM,6CAA6C,GAAG,GAAG,EAAE;IACzD,wBAAwB,GAAG,aAAa,CAAC;AAC3C,CAAC,CAAC;AAEF,MAAM,eAAe,GAAqB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;IAC7D,OAAO,wBAAwB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AACpD,CAAC,CAAC;AAEF,2EAA2E;AAC3E,aAAa;AACb,MAAM,oBAAoB,GAAG,OAAO,CAAC;AAErC,yEAAyE;AACzE,gFAAgF;AAChF,0EAA0E;AAC1E,aAAa;AACb,MAAM,MAAM,GAAG,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;AAExD,uDAAuD;AACvD,MAAM,WAAW,GAAG,GAAG,GAAG,MAAM,CAAC;AAEjC,2EAA2E;AAC3E,sEAAsE;AACtE,MAAM,UAAU,GAAG,IAAI,WAAW,GAAG,CAAC;AAEtC,MAAM,CAAC,GAAG,QAAQ,CAAC;AAEnB,0EAA0E;AAC1E,MAAM,YAAY,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;AAIpD,MAAM,WAAW,GAAG,CAAC,KAAc,EAAsB,EAAE,CACzD,KAAK,KAAK,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,QAAQ,IAAI,OAAO,KAAK,IAAI,UAAU,CAAC,CAAC;AAC7E,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;AAC9B,MAAM,UAAU,GAAG,CAAC,KAAc,EAA8B,EAAE,CAChE,OAAO,CAAC,KAAK,CAAC;IACd,8DAA8D;IAC9D,OAAQ,KAAa,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,UAAU,CAAC;AAE1D,mDAAmD;AACnD,MAAM,UAAU,GAAG,aAAa,CAAC;AACjC,MAAM,eAAe,GAAG,qBAAqB,CAAC;AAC9C,MAAM,SAAS,GAAG,2BAA2B,CAAC;AAE9C,4EAA4E;AAC5E,2EAA2E;AAC3E,SAAS;AACT,6EAA6E;AAC7E,6BAA6B;AAC7B,uEAAuE;AACvE,0EAA0E;AAC1E,2EAA2E;AAC3E,iBAAiB;AAEjB,uEAAuE;AACvE,uEAAuE;AACvE,+DAA+D;AAE/D;;;GAGG;AACH,MAAM,YAAY,GAAG,qDAAqD,CAAC;AAC3E,MAAM,aAAa,GAAG,CAAC,CAAC;AACxB,MAAM,QAAQ,GAAG,CAAC,CAAC;AACnB,MAAM,gBAAgB,GAAG,CAAC,CAAC;AAE3B,MAAM,eAAe,GAAG,MAAM,CAAC;AAC/B;;GAEG;AACH,MAAM,gBAAgB,GAAG,IAAI,CAAC;AAE9B;;;;;;;;;;;;;;;;;;;;;;;;GAwBG;AACH,MAAM,WAAW,GAAG,IAAI,MAAM,CAC5B,KAAK,UAAU,OAAO,SAAS,MAAM,UAAU,KAAK,UAAU,OAAO,eAAe,cAAc,EAClG,GAAG,CACJ,CAAC;AACF,MAAM,YAAY,GAAG,CAAC,CAAC;AACvB,MAAM,cAAc,GAAG,CAAC,CAAC;AACzB,MAAM,iBAAiB,GAAG,CAAC,CAAC;AAC5B,MAAM,UAAU,GAAG,CAAC,CAAC;AAErB,MAAM,uBAAuB,GAAG,IAAI,CAAC;AACrC,MAAM,uBAAuB,GAAG,IAAI,CAAC;AACrC;;;;;GAKG;AACH,MAAM,cAAc,GAAG,8BAA8B,CAAC;AAEtD,2BAA2B;AAC3B,MAAM,WAAW,GAAG,CAAC,CAAC;AACtB,MAAM,UAAU,GAAG,CAAC,CAAC;AAIrB,qBAAqB;AACrB,qDAAqD;AACrD,MAAM,cAAc,GAAG,CAAC,CAAC;AACzB,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB,MAAM,aAAa,GAAG,CAAC,CAAC;AACxB,MAAM,sBAAsB,GAAG,CAAC,CAAC;AACjC,MAAM,UAAU,GAAG,CAAC,CAAC;AACrB,MAAM,YAAY,GAAG,CAAC,CAAC;AACvB,MAAM,YAAY,GAAG,CAAC,CAAC;AAevB;;;GAGG;AACH,MAAM,GAAG,GAAG,CAAC,UAAsB,EAAE,EAAE,CAAC,CACtC,OAA6B,EAC7B,GAAG,MAAiB,EACJ,EAAE,CAAC,CAAC;IACpB,UAAU;IACV,OAAO;IACP,MAAM;CACP,CAAC,CAAC;AAEH;;;GAGG;AACH,MAAM,CAAC,MAAM,IAAI,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC;AAErC;;;GAGG;AACH,MAAM,CAAC,MAAM,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC;AAEnC;;;GAGG;AACH,MAAM,CAAC,MAAM,QAAQ,GAAG,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;AAEnD;;GAEG;AACH,MAAM,CAAC,MAAM,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;AAEjD;;;;;;GAMG;AACH,MAAM,aAAa,GAAG,IAAI,GAAG,EAAkC,CAAC;AAchE;;;;;GAKG;AACH,MAAM,CAAC,MAAM,MAAM,GAAG,CACpB,KAAc,EACd,SAAyC,EACzC,OAAuB,EACZ,EAAE;IACb,MAAM,aAAa,GAAG,OAAO,EAAE,YAAY,IAAI,SAAS,CAAC;IACzD,8DAA8D;IAC9D,IAAI,IAAI,GAAe,aAAqB,CAAC,SAAS,CAAC;IACvD,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,MAAM,OAAO,GAAG,OAAO,EAAE,YAAY,IAAI,IAAI,CAAC;QAC9C,8DAA8D;QAC7D,aAAqB,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,aAAa,CACzD,SAAS,CAAC,YAAY,CAAC,YAAY,EAAE,EAAE,OAAO,CAAC,EAC/C,OAAO,EACP,SAAS,EACT,OAAO,CACR,CAAC;KACH;IACD,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACvB,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,IAAI,2BAA2B,EAAE;IAC/B,MAAM,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,MAAM,CAAC,eAAe,GAAG,eAAe,CAAC;IACzC,IAAI,QAAQ,EAAE;QACZ,MAAM,CAAC,6CAA6C,GAAG,6CAA6C,CAAC;KACtG;CACF;AAED,MAAM,MAAM,GAAG,CAAC,CAAC,gBAAgB,CAC/B,CAAC,EACD,GAAG,CAAC,4CAA4C,EAChD,IAAI,EACJ,KAAK,CACN,CAAC;AAEF,IAAI,wBAAwB,GAAqB,aAAa,CAAC;AAiB/D;;;;;;;;;;;GAWG;AACH,MAAM,eAAe,GAAG,CACtB,OAA6B,EAC7B,IAAgB,EACI,EAAE;IACtB,oEAAoE;IACpE,2EAA2E;IAC3E,0EAA0E;IAC1E,yEAAyE;IACzE,yEAAyE;IACzE,iCAAiC;IACjC,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;IAC7B,MAAM,SAAS,GAAkB,EAAE,CAAC;IACpC,IAAI,IAAI,GAAG,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC;IAE9C,sEAAsE;IACtE,uEAAuE;IACvE,gCAAgC;IAChC,IAAI,eAAmC,CAAC;IAExC,sEAAsE;IACtE,UAAU;IACV,IAAI,KAAK,GAAG,YAAY,CAAC;IAEzB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAC1B,MAAM,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QACrB,gEAAgE;QAChE,oEAAoE;QACpE,mDAAmD;QACnD,oEAAoE;QACpE,kDAAkD;QAClD,IAAI,gBAAgB,GAAG,CAAC,CAAC,CAAC;QAC1B,IAAI,QAA4B,CAAC;QACjC,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,KAA8B,CAAC;QAEnC,sEAAsE;QACtE,iEAAiE;QACjE,OAAO,SAAS,GAAG,CAAC,CAAC,MAAM,EAAE;YAC3B,iEAAiE;YACjE,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC;YAC5B,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,KAAK,KAAK,IAAI,EAAE;gBAClB,MAAM;aACP;YACD,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC;YAC5B,IAAI,KAAK,KAAK,YAAY,EAAE;gBAC1B,IAAI,KAAK,CAAC,aAAa,CAAC,KAAK,KAAK,EAAE;oBAClC,KAAK,GAAG,eAAe,CAAC;iBACzB;qBAAM,IAAI,KAAK,CAAC,aAAa,CAAC,KAAK,SAAS,EAAE;oBAC7C,uCAAuC;oBACvC,KAAK,GAAG,gBAAgB,CAAC;iBAC1B;qBAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;oBACxC,IAAI,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE;wBACxC,6DAA6D;wBAC7D,oCAAoC;wBACpC,eAAe,GAAG,IAAI,MAAM,CAAC,KAAK,KAAK,CAAC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;qBAC3D;oBACD,KAAK,GAAG,WAAW,CAAC;iBACrB;qBAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,KAAK,SAAS,EAAE;oBAChD,mBAAmB;oBACnB,KAAK,GAAG,WAAW,CAAC;iBACrB;aACF;iBAAM,IAAI,KAAK,KAAK,WAAW,EAAE;gBAChC,IAAI,KAAK,CAAC,YAAY,CAAC,KAAK,GAAG,EAAE;oBAC/B,+DAA+D;oBAC/D,QAAQ;oBACR,KAAK,GAAG,eAAe,IAAI,YAAY,CAAC;oBACxC,gEAAgE;oBAChE,qCAAqC;oBACrC,gBAAgB,GAAG,CAAC,CAAC,CAAC;iBACvB;qBAAM,IAAI,KAAK,CAAC,cAAc,CAAC,KAAK,SAAS,EAAE;oBAC9C,0BAA0B;oBAC1B,gBAAgB,GAAG,CAAC,CAAC,CAAC;iBACvB;qBAAM;oBACL,gBAAgB,GAAG,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,iBAAiB,CAAC,CAAC,MAAM,CAAC;oBACrE,QAAQ,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;oBACjC,KAAK;wBACH,KAAK,CAAC,UAAU,CAAC,KAAK,SAAS;4BAC7B,CAAC,CAAC,WAAW;4BACb,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,KAAK,GAAG;gCAC3B,CAAC,CAAC,uBAAuB;gCACzB,CAAC,CAAC,uBAAuB,CAAC;iBAC/B;aACF;iBAAM,IACL,KAAK,KAAK,uBAAuB;gBACjC,KAAK,KAAK,uBAAuB,EACjC;gBACA,KAAK,GAAG,WAAW,CAAC;aACrB;iBAAM,IAAI,KAAK,KAAK,eAAe,IAAI,KAAK,KAAK,gBAAgB,EAAE;gBAClE,KAAK,GAAG,YAAY,CAAC;aACtB;iBAAM;gBACL,mEAAmE;gBACnE,iEAAiE;gBACjE,KAAK,GAAG,WAAW,CAAC;gBACpB,eAAe,GAAG,SAAS,CAAC;aAC7B;SACF;QAED,IAAI,QAAQ,EAAE;YACZ,gEAAgE;YAChE,qEAAqE;YACrE,2DAA2D;YAC3D,OAAO,CAAC,MAAM,CACZ,gBAAgB,KAAK,CAAC,CAAC;gBACrB,KAAK,KAAK,WAAW;gBACrB,KAAK,KAAK,uBAAuB;gBACjC,KAAK,KAAK,uBAAuB,EACnC,0BAA0B,CAC3B,CAAC;SACH;QAED,sBAAsB;QACtB,4DAA4D;QAC5D,yDAAyD;QACzD,qEAAqE;QACrE,kEAAkE;QAClE,yEAAyE;QACzE,oBAAoB;QACpB,sEAAsE;QACtE,qEAAqE;QACrE,wCAAwC;QACxC,IAAI;YACF,KAAK,KAAK,YAAY;gBACpB,CAAC,CAAC,CAAC,GAAG,UAAU;gBAChB,CAAC,CAAC,gBAAgB,IAAI,CAAC;oBACvB,CAAC,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,QAAS,CAAC;wBAC1B,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,gBAAgB,CAAC;4BAC1B,oBAAoB;4BACpB,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,GAAG,MAAM;oBACvC,CAAC,CAAC,CAAC,GAAG,MAAM,GAAG,CAAC,gBAAgB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;KAC7D;IAED,qCAAqC;IACrC,OAAO;QACL,uEAAuE;QACvE,0DAA0D;QAC1D,wEAAwE;QACxE,2EAA2E;QAC3E,yBAAyB;QACzB,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QACpE,SAAS;KACV,CAAC;AACJ,CAAC,CAAC;AAGF,MAAM,YAAY;IAQhB,YACE,EAAC,OAAO,EAAE,UAAU,EAAE,IAAI,EAAiB,EAC3C,OAAuB;QAPzB,gBAAgB;QAChB,WAAM,GAAwB,EAAE,CAAC;QAQ/B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;QACzB,IAAI,IAAiB,CAAC;QACtB,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,YAAY,GAAG,CAAC,CAAC;QACrB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QAE7B,0BAA0B;QAC1B,MAAM,CAAC,IAAI,EAAE,SAAS,CAAC,GAAG,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACzD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC5C,MAAM,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;QAE5C,wCAAwC;QACxC,IAAI,IAAI,KAAK,UAAU,EAAE;YACvB,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC;YACvC,MAAM,UAAU,GAAG,OAAO,CAAC,UAAW,CAAC;YACvC,UAAU,CAAC,MAAM,EAAE,CAAC;YACpB,OAAO,CAAC,MAAM,CAAC,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC;SAC1C;QAED,qEAAqE;QACrE,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,KAAK,IAAI,IAAI,YAAY,GAAG,CAAC,EAAE;YAC9D,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE;gBACvB,kEAAkE;gBAClE,mEAAmE;gBACnE,2BAA2B;gBAC3B,IAAK,IAAgB,CAAC,aAAa,EAAE,EAAE;oBACrC,mEAAmE;oBACnE,oEAAoE;oBACpE,+DAA+D;oBAC/D,MAAM,aAAa,GAAG,EAAE,CAAC;oBACzB,KAAK,MAAM,IAAI,IAAK,IAAgB,CAAC,iBAAiB,EAAE,EAAE;wBACxD,oEAAoE;wBACpE,iEAAiE;wBACjE,+DAA+D;wBAC/D,+DAA+D;wBAC/D,mEAAmE;wBACnE,qEAAqE;wBACrE,mBAAmB;wBACnB,IAAI,IAAI,CAAC,QAAQ,CAAC,oBAAoB,CAAC,EAAE;4BACvC,MAAM,QAAQ,GAAG,SAAS,CAAC,aAAa,EAAE,CAAC,CAAC;4BAC5C,2DAA2D;4BAC3D,MAAM,KAAK,GAAI,IAAgB,CAAC,YAAY,CAC1C,QAAQ,CAAC,WAAW,EAAE,GAAG,oBAAoB,CAC7C,CAAC;4BACH,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;4BACzB,MAAM,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;4BACpC,MAAM,CAAC,GAAG,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAE,CAAC;4BACzC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gCACf,KAAK,EAAE,cAAc;gCACrB,MAAM,EAAE,SAAS;gCACjB,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;gCACX,QAAQ,EAAE,OAAO;gCACjB,YAAY,EACV,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;oCACV,CAAC,CAAC,gBAAgB;oCAClB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;wCACd,CAAC,CAAC,wBAAwB;wCAC1B,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;4CACd,CAAC,CAAC,aAAa;4CACf,CAAC,CAAC,iBAAiB;6BACxB,CAAC,CAAC;4BACH,YAAY,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;yBACpC;6BAAM,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;4BAClC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;4BACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gCACf,KAAK,EAAE,YAAY;gCACnB,MAAM,EAAE,SAAS;6BAClB,CAAC,CAAC;yBACJ;qBACF;oBACD,KAAK,MAAM,IAAI,IAAI,aAAa,EAAE;wBAC/B,IAAgB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;qBACzC;iBACF;gBACD,qEAAqE;gBACrE,mCAAmC;gBACnC,IAAI,cAAc,CAAC,IAAI,CAAE,IAAgB,CAAC,OAAO,CAAC,EAAE;oBAClD,6DAA6D;oBAC7D,2DAA2D;oBAC3D,kCAAkC;oBAClC,MAAM,OAAO,GAAI,IAAgB,CAAC,WAAY,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC7D,MAAM,SAAS,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;oBACrC,IAAI,SAAS,GAAG,CAAC,EAAE;wBAChB,IAAgB,CAAC,WAAW,GAAG,EAAE,CAAC;wBACnC,oDAAoD;wBACpD,0DAA0D;wBAC1D,2DAA2D;wBAC3D,4CAA4C;wBAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,EAAE,CAAC,EAAE,EAAE;4BACjC,IAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,YAAY,EAAE,CAAC,CAAC;4BACvD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,EAAE,SAAS,EAAC,CAAC,CAAC;4BAC3D,YAAY,EAAE,CAAC;yBAChB;wBACA,IAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,YAAY,EAAE,CAAC,CAAC;qBAChE;iBACF;aACF;iBAAM,IAAI,IAAI,CAAC,QAAQ,KAAK,CAAC,EAAE;gBAC9B,MAAM,IAAI,GAAI,IAAgB,CAAC,IAAI,CAAC;gBACpC,IAAI,IAAI,KAAK,WAAW,EAAE;oBACxB,YAAY,EAAE,CAAC;oBACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,SAAS,EAAC,CAAC,CAAC;iBAC1D;qBAAM;oBACL,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;oBACX,OAAO,CAAC,CAAC,GAAI,IAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;wBACjE,kEAAkE;wBAClE,uDAAuD;wBACvD,+DAA+D;wBAC/D,iCAAiC;wBACjC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,YAAY,EAAE,MAAM,EAAE,SAAS,EAAC,CAAC,CAAC;wBAC3D,YAAY,EAAE,CAAC;wBACf,+BAA+B;wBAC/B,CAAC,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;qBACxB;iBACF;aACF;YACD,SAAS,EAAE,CAAC;SACb;IACH,CAAC;IAED,uEAAuE;IACvE,eAAe,CAAC,IAAY;QAC1B,MAAM,QAAQ,GAAG,CAAC,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAC7C,QAAQ,CAAC,SAAS,GAAG,IAAI,CAAC;QAC1B,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF;AAOD,SAAS,gBAAgB,CACvB,IAA6C,EAC7C,KAAc,EACd,WAA4B,IAAI,EAChC,gBAAyB;;IAEzB,IAAI,gBAAgB,GAClB,gBAAgB,KAAK,SAAS;QAC5B,CAAC,CAAE,QAA0B,CAAC,YAAY,EAAE,CAAC,gBAAgB,CAAC;QAC9D,CAAC,CAAE,QAAgD,CAAC,WAAW,CAAC;IACpE,MAAM,wBAAwB,GAAG,WAAW,CAAC,KAAK,CAAC;QACjD,CAAC,CAAC,SAAS;QACX,CAAC,CAAE,KAAyB,CAAC,eAAe,CAAC;IAC/C,IAAI,gBAAgB,EAAE,WAAW,KAAK,wBAAwB,EAAE;QAC9D,gBAAgB,EAAE,uBAAuB,EAAE,CAAC,KAAK,CAAC,CAAC;QACnD,gBAAgB;YACd,wBAAwB,KAAK,SAAS;gBACpC,CAAC,CAAC,SAAS;gBACX,CAAC,CAAC,IAAI,wBAAwB,CAAC;oBAC3B,GAAG,IAAI;oBACP,MAAM,EAAE,IAAI;oBACZ,QAAQ;oBACR,gBAAgB;iBACL,CAAC,CAAC;QACrB,IAAI,gBAAgB,KAAK,SAAS,EAAE;YAClC,OAAE,QAA0B,EAAC,YAAY,QAAZ,YAAY,GAAK,EAAE,EAAC,CAC/C,gBAAgB,CACjB,GAAG,gBAAgB,CAAC;SACtB;aAAM;YACJ,QAAkC,CAAC,WAAW,GAAG,gBAAgB,CAAC;SACpE;KACF;IACD,IAAI,gBAAgB,KAAK,SAAS,EAAE;QAClC,KAAK,GAAG,gBAAgB,CAAC,QAAQ,CAAE,KAAyB,CAAC,MAAM,CAAC,CAAC;KACtE;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;GAGG;AACH,MAAM,gBAAgB;IAWpB,YAAY,QAAkB,EAAE,MAAiB;QARjD,gBAAgB;QAChB,WAAM,GAA4B,EAAE,CAAC;QAIrC,gBAAgB;QAChB,4BAAuB,GAAyB,SAAS,CAAC;QAGxD,IAAI,CAAC,UAAU,GAAG,QAAQ,CAAC;QAC3B,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;IACzB,CAAC;IAED,2EAA2E;IAC3E,6EAA6E;IAC7E,MAAM,CAAC,OAAkC;QACvC,MAAM,EACJ,SAAS,EAAE,EAAC,OAAO,EAAC,EACpB,MAAM,EAAE,KAAK,GACd,GAAG,IAAI,CAAC,UAAU,CAAC;QACpB,MAAM,QAAQ,GAAG,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QAC7C,MAAM,CAAC,WAAW,GAAG,QAAQ,CAAC;QAE9B,IAAI,IAAI,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;QAC7B,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,YAAY,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;QAE5B,OAAO,YAAY,KAAK,SAAS,IAAI,IAAI,KAAK,IAAI,EAAE;YAClD,IAAI,SAAS,KAAK,YAAY,CAAC,MAAM,EAAE;gBACrC,IAAI,IAAsB,CAAC;gBAC3B,IAAI,YAAY,CAAC,KAAK,KAAK,UAAU,EAAE;oBACrC,IAAI,GAAG,IAAI,aAAa,CACtB,IAAmB,EACnB,IAAI,CAAC,WAAW,EAChB,IAAI,EACJ,OAAO,CACR,CAAC;iBACH;qBAAM,IAAI,YAAY,CAAC,KAAK,KAAK,cAAc,EAAE;oBAChD,IAAI,GAAG,IAAI,YAAY,CAAC,YAAY,CAClC,IAAmB,EACnB,YAAY,CAAC,KAAK,EAClB,YAAY,CAAC,QAAQ,EACrB,IAAI,EACJ,OAAO,CACR,CAAC;iBACH;qBAAM,IAAI,YAAY,CAAC,KAAK,KAAK,YAAY,EAAE;oBAC9C,IAAI,GAAG,IAAI,eAAe,CAAC,IAAmB,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;iBAChE;gBACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,YAAY,GAAG,KAAK,CAAC,EAAE,SAAS,CAAC,CAAC;aACnC;YACD,IAAI,YAAY,KAAK,SAAS,IAAI,SAAS,KAAK,YAAY,CAAC,MAAM,EAAE;gBACnE,IAAI,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;gBACzB,SAAS,EAAE,CAAC;aACb;SACF;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,OAAO,CAAC,MAAsB;QAC5B,IAAI,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;YAC9B,IAAI,IAAI,KAAK,SAAS,EAAE;gBACtB,IAAK,IAAsB,CAAC,OAAO,KAAK,SAAS,EAAE;oBAChD,IAAsB,CAAC,UAAU,CAAC,MAAM,EAAE,IAAqB,EAAE,CAAC,CAAC,CAAC;oBACrE,oEAAoE;oBACpE,kEAAkE;oBAClE,qEAAqE;oBACrE,CAAC,IAAK,IAAsB,CAAC,OAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;iBAClD;qBAAM;oBACL,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC5B;aACF;YACD,CAAC,EAAE,CAAC;SACL;IACH,CAAC;CACF;AA0DD,MAAM,aAAa;IAyBjB,YACE,SAAoB,EACpB,OAAyB,EACzB,MAAgD,EAChD,OAAkC;QA5B3B,SAAI,GAAG,UAAU,CAAC;QAa3B,wEAAwE;QACxE,0BAA0B;QAC1B,gBAAgB;QAChB,4BAAuB,GAAyB,SAAS,CAAC;QAcxD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,2BAA2B,EAAE;YAC/B,oDAAoD;YACpD,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;SACjC;IACH,CAAC;IAED;;;;;OAKG;IACH,YAAY,CAAC,WAAoB;QAC/B,IAAI,CAAC,uBAAuB,EAAE,CAAC,WAAW,CAAC,CAAC;IAC9C,CAAC;IAED,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,WAAW,CAAC,UAAW,CAAC;IACtC,CAAC;IAED,UAAU,CAAC,KAAc,EAAE,kBAAmC,IAAI;QAChE,KAAK,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,eAAe,CAAC,CAAC;QACvD,IAAI,WAAW,CAAC,KAAK,CAAC,EAAE;YACtB,IAAI,KAAK,KAAK,OAAO,EAAE;gBACrB,IAAI,CAAC,OAAO,EAAE,CAAC;gBACf,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;aACjC;iBAAM,IAAI,KAAK,KAAK,IAAI,CAAC,gBAAgB,IAAI,KAAK,KAAK,QAAQ,EAAE;gBAChE,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACzB;SACF;aAAM,IAAK,KAAwB,CAAC,UAAU,KAAK,SAAS,EAAE;YAC7D,IAAI,CAAC,qBAAqB,CAAC,KAAuB,CAAC,CAAC;SACrD;aAAM,IAAK,KAAc,CAAC,QAAQ,KAAK,SAAS,EAAE;YACjD,IAAI,CAAC,WAAW,CAAC,KAAa,CAAC,CAAC;SACjC;aAAM,IAAI,UAAU,CAAC,KAAK,CAAC,EAAE;YAC5B,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;SAC7B;aAAM;YACL,kDAAkD;YAClD,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SACzB;IACH,CAAC;IAEO,OAAO,CAAiB,IAAO,EAAE,GAAG,GAAG,IAAI,CAAC,SAAS;QAC3D,OAAO,IAAI,CAAC,WAAW,CAAC,UAAW,CAAC,YAAY,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;IAC9D,CAAC;IAEO,WAAW,CAAC,KAAW;QAC7B,IAAI,IAAI,CAAC,gBAAgB,KAAK,KAAK,EAAE;YACnC,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,IACE,2BAA2B;gBAC3B,wBAAwB,KAAK,aAAa,EAC1C;gBACA,MAAM,cAAc,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC;gBAC7D,IAAI,cAAc,KAAK,OAAO,IAAI,cAAc,KAAK,QAAQ,EAAE;oBAC7D,IAAI,CAAC,OAAO,CACV,IAAI,IAAI,CACN,6BAA6B;wBAC3B,0CAA0C,CAC7C,CACF,CAAC;oBACF,OAAO;iBACR;aACF;YACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SAC7C;IACH,CAAC;IAEO,WAAW,CAAC,KAAc;QAChC,MAAM,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC;QAC1C,yDAAyD;QACzD,yCAAyC;QACzC,KAAK,KAAL,KAAK,GAAK,EAAE,EAAC;QACb,gFAAgF;QAChF,IACE,IAAI,KAAK,IAAI;YACb,IAAI,CAAC,QAAQ,KAAK,CAAC,CAAC,oBAAoB;YACxC,CAAC,IAAI,CAAC,SAAS,KAAK,IAAI;gBACtB,CAAC,CAAC,IAAI,CAAC,WAAW,KAAK,IAAI;gBAC3B,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,EAC5C;YACA,IAAI,2BAA2B,EAAE;gBAC/B,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,EAAE;oBACrC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;iBACjE;gBACD,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;aACpC;YACD,sEAAsE;YACtE,2CAA2C;YAC1C,IAAa,CAAC,IAAI,GAAG,KAAe,CAAC;SACvC;aAAM;YACL,IAAI,2BAA2B,EAAE;gBAC/B,MAAM,QAAQ,GAAG,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;gBAC7C,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBAC3B,oEAAoE;gBACpE,mEAAmE;gBACnE,sEAAsE;gBACtE,kEAAkE;gBAClE,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,EAAE;oBACrC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;iBACrE;gBACD,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;gBACnC,QAAQ,CAAC,IAAI,GAAG,KAAe,CAAC;aACjC;iBAAM;gBACL,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,cAAc,CAAC,KAAe,CAAC,CAAC,CAAC;aACrD;SACF;QACD,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;IAChC,CAAC;IAEO,qBAAqB,CAAC,MAAsB;QAClD,MAAM,EAAC,MAAM,EAAE,OAAO,EAAC,GAAG,MAAM,CAAC;QACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;QACrD,IAAK,IAAI,CAAC,gBAAqC,EAAE,UAAU,KAAK,QAAQ,EAAE;YACvE,IAAI,CAAC,gBAAqC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;SAC7D;aAAM;YACL,MAAM,QAAQ,GAAG,IAAI,gBAAgB,CAAC,QAAS,EAAE,IAAI,CAAC,CAAC;YACvD,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAC/C,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACzB,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;YAC3B,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC;SAClC;IACH,CAAC;IAED,uEAAuE;IACvE,gBAAgB;IAChB,aAAa,CAAC,OAA6B,EAAE,MAAsB;QACjE,IAAI,QAAQ,GAAG,aAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC1C,IAAI,QAAQ,KAAK,SAAS,EAAE;YAC1B,aAAa,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;SACnE;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEO,eAAe,CAAC,KAAwB;QAC9C,uEAAuE;QACvE,wEAAwE;QACxE,2EAA2E;QAC3E,2EAA2E;QAC3E,uEAAuE;QAEvE,2DAA2D;QAC3D,mEAAmE;QACnE,mEAAmE;QACnE,wBAAwB;QACxB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE;YACnC,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;YAC3B,IAAI,CAAC,OAAO,EAAE,CAAC;SAChB;QAED,2EAA2E;QAC3E,+BAA+B;QAC/B,MAAM,SAAS,GAAG,IAAI,CAAC,gBAAmC,CAAC;QAC3D,IAAI,SAAS,GAAG,CAAC,CAAC;QAClB,IAAI,QAAmC,CAAC;QAExC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,IAAI,SAAS,KAAK,SAAS,CAAC,MAAM,EAAE;gBAClC,wCAAwC;gBACxC,sEAAsE;gBACtE,yCAAyC;gBACzC,kDAAkD;gBAClD,SAAS,CAAC,IAAI,CACZ,CAAC,QAAQ,GAAG,IAAI,aAAa,CAC3B,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC,EAC5B,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC,EAC5B,IAAI,EACJ,IAAI,CAAC,OAAO,CACb,CAAC,CACH,CAAC;aACH;iBAAM;gBACL,yBAAyB;gBACzB,QAAQ,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;aACjC;YACD,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAC1B,SAAS,EAAE,CAAC;SACb;QAED,IAAI,SAAS,GAAG,SAAS,CAAC,MAAM,EAAE;YAChC,kCAAkC;YAClC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAU,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;YAC1D,gEAAgE;YAChE,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC;SAC9B;IACH,CAAC;IAED;;;;;;;;;;OAUG;IACH,OAAO,CACL,QAA0B,IAAI,CAAC,WAAW,CAAC,WAAW,EACtD,IAAa;QAEb,IAAI,CAAC,uBAAuB,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAClD,OAAO,KAAK,IAAI,KAAK,KAAK,IAAI,CAAC,SAAS,EAAE;YACxC,MAAM,CAAC,GAAG,KAAM,CAAC,WAAW,CAAC;YAC7B,KAAM,CAAC,MAAM,EAAE,CAAC;YAChB,KAAK,GAAG,CAAC,CAAC;SACX;IACH,CAAC;CACF;AAGD,MAAM,iBAAiB;IAqCrB,YACE,OAAoB,EACpB,IAAY,EACZ,OAA8B,EAC9B,MAAkC,EAClC,OAAkC;QAzC3B,SAAI,GAAG,cAIK,CAAC;QAWtB,gBAAgB;QAChB,qBAAgB,GAA6B,OAAO,CAAC;QAKrD,gBAAgB;QAChB,4BAAuB,GAAyB,SAAS,CAAC;QAG1D,gBAAgB;QAChB,2BAAsB,GAIV,SAAS,CAAC;QAapB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAChE,IAAI,CAAC,gBAAgB,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACpE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;SACxB;aAAM;YACL,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC;SACjC;QACD,IAAI,2BAA2B,EAAE;YAC/B,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;SAC7B;IACH,CAAC;IAxBD,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;IAC9B,CAAC;IAwBD;;;;;;;;;;;;;;;;;;;;;OAqBG;IACH,UAAU,CACR,KAA+B,EAC/B,kBAAmC,IAAI,EACvC,UAAmB,EACnB,QAAkB;QAElB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC;QAE7B,4DAA4D;QAC5D,IAAI,MAAM,GAAG,KAAK,CAAC;QAEnB,IAAI,OAAO,KAAK,SAAS,EAAE;YACzB,4BAA4B;YAC5B,KAAK,GAAG,gBAAgB,CAAC,IAAI,EAAE,KAAK,EAAE,eAAe,EAAE,CAAC,CAAC,CAAC;YAC1D,MAAM;gBACJ,CAAC,WAAW,CAAC,KAAK,CAAC;oBACnB,CAAC,KAAK,KAAK,IAAI,CAAC,gBAAgB,IAAI,KAAK,KAAK,QAAQ,CAAC,CAAC;YAC1D,IAAI,MAAM,EAAE;gBACV,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;aAC/B;SACF;aAAM;YACL,qBAAqB;YACrB,MAAM,MAAM,GAAG,KAAuB,CAAC;YACvC,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YAEnB,IAAI,CAAC,EAAE,CAAC,CAAC;YACT,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBACvC,CAAC,GAAG,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,UAAW,GAAG,CAAC,CAAC,EAAE,eAAe,EAAE,CAAC,CAAC,CAAC;gBAExE,IAAI,CAAC,KAAK,QAAQ,EAAE;oBAClB,mEAAmE;oBACnE,CAAC,GAAI,IAAI,CAAC,gBAAmC,CAAC,CAAC,CAAC,CAAC;iBAClD;gBACD,MAAM,KAAN,MAAM,GACJ,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,KAAM,IAAI,CAAC,gBAAmC,CAAC,CAAC,CAAC,EAAC;gBACxE,IAAI,CAAC,KAAK,OAAO,EAAE;oBACjB,KAAK,GAAG,OAAO,CAAC;iBACjB;qBAAM,IAAI,KAAK,KAAK,OAAO,EAAE;oBAC5B,KAAK,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC,GAAG,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;iBACrC;gBACD,oEAAoE;gBACpE,oBAAoB;gBACnB,IAAI,CAAC,gBAAmC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;aAClD;SACF;QACD,IAAI,MAAM,IAAI,CAAC,QAAQ,EAAE;YACvB,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;SAC1B;IACH,CAAC;IAED,gBAAgB;IAChB,YAAY,CAAC,KAAc;QACzB,IAAI,KAAK,KAAK,OAAO,EAAE;YACrB,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACzC;aAAM;YACL,IAAI,2BAA2B,EAAE;gBAC/B,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE;oBACjC,IAAI,CAAC,UAAU,GAAG,wBAAwB,CACxC,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,IAAI,EACT,WAAW,CACZ,CAAC;iBACH;gBACD,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;aACtC;YACD,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,KAAK,IAAI,EAAE,CAAW,CAAC,CAAC;SAC/D;IACH,CAAC;CACF;AAGD,MAAM,gBAAiB,SAAQ,iBAAiB;IAAhD;;QACW,SAAI,GAAG,aAAa,CAAC;IAiBhC,CAAC;IAfC,gBAAgB;IAChB,YAAY,CAAC,KAAc;QACzB,IAAI,2BAA2B,EAAE;YAC/B,IAAI,IAAI,CAAC,UAAU,KAAK,SAAS,EAAE;gBACjC,IAAI,CAAC,UAAU,GAAG,wBAAwB,CACxC,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,IAAI,EACT,UAAU,CACX,CAAC;aACH;YACD,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;SAChC;QACD,8DAA8D;QAC7D,IAAI,CAAC,OAAe,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,KAAK,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC;IAC3E,CAAC;CACF;AAGD,MAAM,wBAAyB,SAAQ,iBAAiB;IAAxD;;QACW,SAAI,GAAG,sBAAsB,CAAC;IAUzC,CAAC;IARC,gBAAgB;IAChB,YAAY,CAAC,KAAc;QACzB,IAAI,KAAK,IAAI,KAAK,KAAK,OAAO,EAAE;YAC9B,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;SAC1C;aAAM;YACL,IAAI,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACzC;IACH,CAAC;CACF;AAiBD,MAAM,aAAc,SAAQ,iBAAiB;IAA7C;;QACW,SAAI,GAAG,UAAU,CAAC;IA2D7B,CAAC;IAzDC,0EAA0E;IAC1E,2CAA2C;IAC3C,gBAAgB;IAChB,UAAU,CAAC,WAAoB,EAAE,kBAAmC,IAAI;QACtE,WAAW;YACT,gBAAgB,CAAC,IAAI,EAAE,WAAW,EAAE,eAAe,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC;QACrE,IAAI,WAAW,KAAK,QAAQ,EAAE;YAC5B,OAAO;SACR;QACD,MAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAE1C,0EAA0E;QAC1E,sBAAsB;QACtB,MAAM,oBAAoB,GACxB,CAAC,WAAW,KAAK,OAAO,IAAI,WAAW,KAAK,OAAO,CAAC;YACnD,WAAwC,CAAC,OAAO;gBAC9C,WAAwC,CAAC,OAAO;YAClD,WAAwC,CAAC,IAAI;gBAC3C,WAAwC,CAAC,IAAI;YAC/C,WAAwC,CAAC,OAAO;gBAC9C,WAAwC,CAAC,OAAO,CAAC;QAEtD,uEAAuE;QACvE,iCAAiC;QACjC,MAAM,iBAAiB,GACrB,WAAW,KAAK,OAAO;YACvB,CAAC,WAAW,KAAK,OAAO,IAAI,oBAAoB,CAAC,CAAC;QAEpD,IAAI,oBAAoB,EAAE;YACxB,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAC9B,IAAI,CAAC,IAAI,EACT,IAAI,EACJ,WAAuC,CACxC,CAAC;SACH;QACD,IAAI,iBAAiB,EAAE;YACrB,kEAAkE;YAClE,iEAAiE;YACjE,0BAA0B;YAC1B,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAC3B,IAAI,CAAC,IAAI,EACT,IAAI,EACJ,WAAuC,CACxC,CAAC;SACH;QACD,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC;IACtC,CAAC;IAED,WAAW,CAAC,KAAY;QACtB,IAAI,OAAO,IAAI,CAAC,gBAAgB,KAAK,UAAU,EAAE;YAC/C,iEAAiE;YACjE,iDAAiD;YACjD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,IAAI,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SACvE;aAAM;YACJ,IAAI,CAAC,gBAAwC,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;SACnE;IACH,CAAC;CACF;AAGD,MAAM,eAAe;IAwBnB,YACS,OAAgB,EACvB,MAAsB,EACtB,OAAkC;QAF3B,YAAO,GAAP,OAAO,CAAS;QAxBhB,SAAI,GAAG,YAAY,CAAC;QAW7B,gBAAgB;QAChB,4BAAuB,GAAyB,SAAS,CAAC;QAE1D,gBAAgB;QAChB,2BAAsB,GAIV,SAAS,CAAC;QASpB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;QACvB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,UAAU,CAAC,KAAc;QACvB,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IAChC,CAAC;CACF;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,CAAC,MAAM,SAAS,GAAG;IACvB,kBAAkB;IAClB,qBAAqB,EAAE,oBAAoB;IAC3C,OAAO,EAAE,MAAM;IACf,YAAY,EAAE,WAAW;IACzB,YAAY,EAAE,WAAW;IACzB,gBAAgB,EAAE,eAAe;IACjC,kBAAkB;IAClB,iBAAiB,EAAE,gBAAgB;IACnC,WAAW,EAAE,UAAU;IACvB,iBAAiB,EAAE,gBAAgB;IACnC,wCAAwC;IACxC,UAAU,EAAE,aAAa;IACzB,cAAc,EAAE,iBAA6C;IAC7D,qBAAqB,EAAE,wBAAoD;IAC3E,UAAU,EAAE,aAAyC;IACrD,aAAa,EAAE,gBAA4C;CAC5D,CAAC;AAEF,+BAA+B;AAC/B,8DAA8D;AAC7D,UAAkB,CAAC,wBAAwB,CAAC,EAAE,CAAC,YAAY,EAAE,aAAa,CAAC,CAAC;AAE7E,2EAA2E;AAC3E,kEAAkE;AAClE,2DAA2D;AAC3D,8DAA8D;AAC9D,OAAE,UAAkB,EAAC,iBAAiB,SAAjB,iBAAiB,IAAM,EAAE,EAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// IMPORTANT: these imports must be type-only\nimport {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TODO (justinfagnani): can we get away with `\\s`?\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\0-\\x1F\\x7F-\\x9F \"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n// TODO (justinfagnani): we detect many more parsing edge-cases than we\n// used to, and many of those are of dubious value. Decide and document\n// how to relax correctness to simplify the regexes and states.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult = {\n  _$litType$: ResultType;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = (_$litType$: ResultType) => (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): TemplateResult => ({\n  _$litType$,\n  strings,\n  values,\n});\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new Map<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: EventTarget;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)._$litPart;\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)._$litPart = part = new ChildPartImpl(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [string, string[]] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  const attrNames: Array<string> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) + marker\n        : s + marker + (attrNameEndIndex === -2 ? `:${i}` : '');\n  }\n\n  // Returned as an array for terseness\n  return [\n    // We don't technically need to close the SVG tag since the parser will\n    // handle it for us, but the SSR parser doesn't like that.\n    // Note that the html must end with a node after the final expression to\n    // ensure the last ChildPart has an end node, hence adding a comment if the\n    // last string was empty.\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : ''),\n    attrNames,\n  ];\n};\n\nexport type Template = Interface<TemplateImpl>;\nclass TemplateImpl {\n  /** @internal */\n  _$element!: HTMLTemplateElement;\n  /** @internal */\n  _parts: Array<TemplatePart> = [];\n  // Note, this is used by the `platform-support` module.\n  _$options?: RenderOptions;\n\n  constructor(\n    {strings, _$litType$: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    this._$options = options;\n    let node: Node | null;\n    let nodeIndex = 0;\n    let bindingIndex = 0;\n    let attrNameIndex = 0;\n    const l = strings.length - 1;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this._$element = this._$createElement(html);\n    walker.currentNode = this._$element.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this._$element.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && bindingIndex < l) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              // Lowercase for case-sensitive SVG attributes like viewBox\n              const value = (node as Element).getAttribute(\n                realName.toLowerCase() + boundAttributeSuffix\n              )!;\n              attrsToRemove.push(name);\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              this._parts.push({\n                _type: ATTRIBUTE_PART,\n                _index: nodeIndex,\n                _name: m[2],\n                _strings: statics,\n                _constructor:\n                  m[1] === '.'\n                    ? PropertyPartImpl\n                    : m[1] === '?'\n                    ? BooleanAttributePartImpl\n                    : m[1] === '@'\n                    ? EventPartImpl\n                    : AttributePartImpl,\n              });\n              bindingIndex += statics.length - 1;\n            } else if (name.startsWith(marker)) {\n              attrsToRemove.push(name);\n              this._parts.push({\n                _type: ELEMENT_PART,\n                _index: nodeIndex,\n              });\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i] || createMarker());\n              this._parts.push({_type: CHILD_PART, _index: ++nodeIndex});\n              bindingIndex++;\n            }\n            (node as Element).append(strings[lastIndex] || createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          bindingIndex++;\n          this._parts.push({_type: CHILD_PART, _index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            this._parts.push({_type: COMMENT_PART, _index: nodeIndex});\n            bindingIndex++;\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  _$createElement(html: string) {\n    const template = d.createElement('template');\n    template.innerHTML = html;\n    return template;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnetableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  _$parent: DirectiveParent = part,\n  _$attributeIndex?: number\n): unknown {\n  let currentDirective =\n    _$attributeIndex !== undefined\n      ? (_$parent as AttributePart).__directives?.[_$attributeIndex]\n      : (_$parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : (value as DirectiveResult)._$litDirective$;\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    currentDirective?._$setDirectiveConnected?.(false);\n    currentDirective =\n      nextDirectiveConstructor === undefined\n        ? undefined\n        : new nextDirectiveConstructor({\n            ...part,\n            _$part: part,\n            _$parent,\n            _$attributeIndex,\n          } as PartInfo);\n    if (_$attributeIndex !== undefined) {\n      ((_$parent as AttributePart).__directives ??= [])[\n        _$attributeIndex\n      ] = currentDirective;\n    } else {\n      (_$parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = currentDirective._resolve((value as DirectiveResult).values);\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      _$element: {content},\n      _parts: parts,\n    } = this._$template;\n    const fragment = d.importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode();\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined && node !== null) {\n      if (nodeIndex === templatePart._index) {\n        let part: Part | undefined;\n        if (templatePart._type === CHILD_PART) {\n          part = new ChildPartImpl(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart._type === ATTRIBUTE_PART) {\n          part = new templatePart._constructor(\n            node as HTMLElement,\n            templatePart._name,\n            templatePart._strings,\n            this,\n            options\n          );\n        } else if (templatePart._type === ELEMENT_PART) {\n          part = new ElementPartImpl(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (templatePart !== undefined && nodeIndex !== templatePart._index) {\n        node = walker.nextNode();\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributePartConstructor = {\n  new (\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ): AttributePart;\n};\ntype AttributeTemplatePart = {\n  readonly _type: typeof ATTRIBUTE_PART;\n  readonly _index: number;\n  readonly _name: string;\n  /** @internal */\n  readonly _constructor: AttributePartConstructor;\n  /** @internal */\n  readonly _strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly _type: typeof CHILD_PART;\n  readonly _index: number;\n};\ntype ElementTemplatePart = {\n  readonly _type: typeof ELEMENT_PART;\n  readonly _index: number;\n};\ntype CommentTemplatePart = {\n  readonly _type: typeof COMMENT_PART;\n  readonly _index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\ntype Interface<T> = {[P in keyof T]: T[P]};\n\nexport type ChildPart = Interface<ChildPartImpl>;\nclass ChildPartImpl {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // DisconnectableDirective\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `DisconnectableDirectives` contained\n   * within this part and runs their `disconnectedCallback` or\n   * `reconnectedCallback`, according to the `isConnected` argument.\n   * @param isConnected\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  get parentNode(): Node {\n    return this._$startNode.parentNode!;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      if (value === nothing) {\n        this._$clear();\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n    } else if ((value as TemplateResult)._$litType$ !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return this._$startNode.parentNode!.insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = this._$startNode.nextSibling;\n    // Make sure undefined and null render as an empty string\n    // TODO: use `nothing` to clear the node?\n    value ??= '';\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? node.nextSibling === null\n        : node === this._$endNode.previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(result: TemplateResult): void {\n    const {values, strings} = result;\n    const template = this._$getTemplate(strings, result);\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template!, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(strings: TemplateStringsArray, result: TemplateResult) {\n    let template = templateCache.get(strings);\n    if (template === undefined) {\n      templateCache.set(strings, (template = new TemplateImpl(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPartImpl[];\n    let partIndex = 0;\n    let itemPart: ChildPartImpl | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/Polymer/lit-html/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPartImpl(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(itemPart?._$endNode!.nextSibling, partIndex);\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = this._$startNode.nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = start!.nextSibling;\n      start!.remove();\n      start = n;\n    }\n  }\n}\n\nexport type AttributePart = Interface<AttributePartImpl>;\nclass AttributePartImpl {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      this.element.removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      this.element.setAttribute(this.name, (value ?? '') as string);\n    }\n  }\n}\n\nexport type PropertyPart = Interface<PropertyPartImpl>;\nclass PropertyPartImpl extends AttributePartImpl {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type BooleanAttributePart = Interface<BooleanAttributePartImpl>;\nclass BooleanAttributePartImpl extends AttributePartImpl {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      this.element.setAttribute(this.name, '');\n    } else {\n      this.element.removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type EventPart = Interface<EventPartImpl>;\nclass EventPartImpl extends AttributePartImpl {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this._$element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type ElementPart = Interface<ElementPartImpl>;\nclass ElementPartImpl {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _$private object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * @private\n */\nexport const _$private = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPartImpl,\n  _AttributePart: AttributePartImpl as AttributePartConstructor,\n  _BooleanAttributePart: BooleanAttributePartImpl as AttributePartConstructor,\n  _EventPart: EventPartImpl as AttributePartConstructor,\n  _PropertyPart: PropertyPartImpl as AttributePartConstructor,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(TemplateImpl, ChildPartImpl);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-pre.5');\n"]}