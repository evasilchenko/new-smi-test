{"version":3,"file":"platform-support.js","sourceRoot":"","sources":["../src/platform-support.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * lit-html patch to support browsers without native web components.\n *\n * This module should be used in addition to loading the web components\n * polyfills via @webcomponents/webcomponentjs. When using those polyfills\n * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill.\n * Scoping classes are added to DOM nodes to facilitate CSS scoping that\n * simulates the style scoping Shadow DOM provides. ShadyDOM does this scoping\n * to all elements added to the DOM. This module provides an important\n * optimization for this process by pre-scoping lit-html template\n * DOM. This means ShadyDOM does not have to scope each instance of the\n * template DOM. Instead, each template is scoped only once.\n *\n * Creating scoped CSS is not covered by this module. It is, however, integrated\n * into the lit-element and @lit/reactive-element packages. See the ShadyCSS docs\n * for how to apply scoping to CSS:\n * https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#usage.\n *\n * @packageDocumentation\n */\n\nconst needsPlatformSupport = !!(\n  window.ShadyCSS !== undefined &&\n  (!window.ShadyCSS.nativeShadow || window.ShadyCSS.ApplyShim)\n);\n\ninterface RenderOptions {\n  readonly renderBefore?: ChildNode | null;\n  scope?: string;\n}\n\ninterface ShadyTemplateResult {\n  strings: TemplateStringsArray;\n  _$litType$?: string;\n}\n\ninterface PatchableChildPart {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableChildPart;\n  _$committedValue: unknown;\n  _$startNode: ChildNode;\n  _$endNode: ChildNode | null;\n  options: RenderOptions;\n  _$setValue(value: unknown): void;\n  _$getTemplate(\n    strings: TemplateStringsArray,\n    result: ShadyTemplateResult\n  ): HTMLTemplateElement;\n}\n\ninterface PatchableTemplate {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-misused-new\n  new (...args: any[]): PatchableTemplate;\n  _$createElement(html: string): HTMLTemplateElement;\n  _$element: HTMLTemplateElement;\n  _$options: RenderOptions;\n}\n\ninterface PatchableTemplateInstance {\n  _$template: PatchableTemplate;\n}\n\n// Scopes that have had styling prepared. Note, must only be done once per\n// scope.\nconst styledScopes: Set<string> = new Set();\n// Map of css per scope. This is collected during first scope render, used when\n// styling is prepared, and then discarded.\nconst scopeCssStore: Map<string, string[]> = new Map();\n\n/**\n * lit-html patches. These properties cannot be renamed.\n * * ChildPart.prototype._$getTemplate\n * * ChildPart.prototype._$setValue\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport'] ??= (\n  Template: PatchableTemplate,\n  ChildPart: PatchableChildPart\n) => {\n  if (!needsPlatformSupport) {\n    return;\n  }\n\n  // console.log(\n  //   '%c Making lit-html compatible with ShadyDOM/CSS.',\n  //   'color: lightgreen; font-style: italic'\n  // );\n\n  const needsPrepareStyles = (name: string | undefined) =>\n    name !== undefined && !styledScopes.has(name);\n\n  const cssForScope = (name: string) => {\n    let scopeCss = scopeCssStore.get(name);\n    if (scopeCss === undefined) {\n      scopeCssStore.set(name, (scopeCss = []));\n    }\n    return scopeCss;\n  };\n\n  const prepareStyles = (name: string, template: HTMLTemplateElement) => {\n    // Get styles\n    const scopeCss = cssForScope(name);\n    if (scopeCss.length) {\n      const style = document.createElement('style');\n      style.textContent = scopeCss.join('\\n');\n      // Note, it's important to add the style to the *end* of the template so\n      // it doesn't mess up part indices.\n      template.content.appendChild(style);\n    }\n    // Mark this scope as styled.\n    styledScopes.add(name);\n    // Remove stored data since it's no longer needed.\n    scopeCssStore.delete(name);\n    // ShadyCSS removes scopes and removes the style under ShadyDOM and leaves\n    // it under native Shadow DOM\n    window.ShadyCSS!.prepareTemplateStyles(template, name);\n  };\n\n  const scopedTemplateCache = new Map<\n    string,\n    Map<TemplateStringsArray, PatchableTemplate>\n  >();\n\n  // Note, it's ok to subclass Template since it's only used via ChildPart.\n  class ShadyTemplate extends Template {\n    /**\n     * Override to extract style elements from the template\n     * and store all style.textContent in the shady scope data.\n     */\n    _$createElement(html: string) {\n      const template = super._$createElement(html);\n      const scope = this._$options?.scope;\n      if (scope !== undefined) {\n        if (!window.ShadyCSS!.nativeShadow) {\n          window.ShadyCSS!.prepareTemplateDom(template, scope);\n        }\n        const scopeCss = cssForScope(scope);\n        // Remove styles and store textContent.\n        const styles = template.content.querySelectorAll(\n          'style'\n        ) as NodeListOf<HTMLStyleElement>;\n        // Store the css in this template in the scope css and remove the <style>\n        // from the template _before_ the node-walk captures part indices\n        scopeCss.push(\n          ...Array.from(styles).map((style) => {\n            style.parentNode?.removeChild(style);\n            return style.textContent!;\n          })\n        );\n      }\n      return template;\n    }\n  }\n\n  const renderContainer = document.createDocumentFragment();\n  const renderContainerMarker = document.createComment('');\n\n  const childPartProto = ChildPart.prototype;\n  /**\n   * Patch to apply gathered css via ShadyCSS. This is done only once per scope.\n   */\n  const setValue = childPartProto._$setValue;\n  childPartProto._$setValue = function (\n    this: PatchableChildPart,\n    value: unknown\n  ) {\n    const container = this._$startNode.parentNode!;\n    const scope = this.options.scope;\n    if (container instanceof ShadowRoot && needsPrepareStyles(scope)) {\n      // Note, @apply requires outer => inner scope rendering on initial\n      // scope renders to apply property values correctly. Style preparation\n      // is tied to rendering into `shadowRoot`'s and this is typically done by\n      // custom elements. If this is done in `connectedCallback`, as is typical,\n      // the code below ensures the right order since content is rendered\n      // into a fragment first so the hosting element can prepare styles first.\n      // If rendering is done in the constructor, this won't work, but that's\n      // not supported in ShadyDOM anyway.\n      const startNode = this._$startNode;\n      const endNode = this._$endNode;\n\n      // Temporarily move this part into the renderContainer.\n      renderContainer.appendChild(renderContainerMarker);\n      this._$startNode = renderContainerMarker;\n      this._$endNode = null;\n\n      // Note, any nested template results render here and their styles will\n      // be extracted and collected.\n      setValue.call(this, value);\n\n      // Get the template for this result or create a dummy one if a result\n      // is not being rendered.\n      const template = (value as ShadyTemplateResult)?._$litType$\n        ? (this._$committedValue as PatchableTemplateInstance)._$template\n            ._$element\n        : document.createElement('template');\n      prepareStyles(scope!, template);\n\n      // Note, this is the temporary startNode.\n      renderContainer.removeChild(renderContainerMarker);\n      // When using native Shadow DOM, include prepared style in shadowRoot.\n      if (window.ShadyCSS?.nativeShadow) {\n        const style = template.content.querySelector('style');\n        if (style !== null) {\n          renderContainer.appendChild(style.cloneNode(true));\n        }\n      }\n      container.insertBefore(renderContainer, endNode);\n      // Move part back to original container.\n      this._$startNode = startNode;\n      this._$endNode = endNode;\n    } else {\n      setValue.call(this, value);\n    }\n  };\n\n  /**\n   * Patch ChildPart._$getTemplate to look up templates in a cache bucketed\n   * by element name.\n   */\n  childPartProto._$getTemplate = function (\n    strings: TemplateStringsArray,\n    result: ShadyTemplateResult\n  ) {\n    const scope = this.options.scope!;\n    let templateCache = scopedTemplateCache.get(scope);\n    if (templateCache === undefined) {\n      scopedTemplateCache.set(scope, (templateCache = new Map()));\n    }\n    let template = templateCache.get(strings);\n    if (template === undefined) {\n      templateCache.set(\n        strings,\n        (template = new ShadyTemplate(result, this.options))\n      );\n    }\n    return template;\n  };\n};\n"]}