/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import { Directive } from './directive.js';
/**
 * Used to sanitize any value before it is written into the DOM. This can be
 * used to implement a security policy of allowed and disallowed values in
 * order to prevent XSS attacks.
 *
 * One way of using this callback would be to check attributes and properties
 * against a list of high risk fields, and require that values written to such
 * fields be instances of a class which is safe by construction. Closure's Safe
 * HTML Types is one implementation of this technique (
 * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).
 * The TrustedTypes polyfill in API-only mode could also be used as a basis
 * for this technique (https://github.com/WICG/trusted-types).
 *
 * @param node The HTML node (usually either a #text node or an Element) that
 *     is being written to. Note that this is just an exemplar node, the write
 *     may take place against another instance of the same class of node.
 * @param name The name of an attribute or property (for example, 'href').
 * @param type Indicates whether the write that's about to be performed will
 *     be to a property or a node.
 * @return A function that will sanitize this class of writes.
 */
export declare type SanitizerFactory = (node: Node, name: string, type: 'property' | 'attribute') => ValueSanitizer;
/**
 * A function which can sanitize values that will be written to a specific kind
 * of DOM sink.
 *
 * See SanitizerFactory.
 *
 * @param value The value to sanitize. Will be the actual value passed into
 *     the lit-html template literal, so this could be of any type.
 * @return The value to write to the DOM. Usually the same as the input value,
 *     unless sanitization is needed.
 */
export declare type ValueSanitizer = (value: unknown) => unknown;
/** TemplateResult types */
declare const HTML_RESULT = 1;
declare const SVG_RESULT = 2;
declare type ResultType = typeof HTML_RESULT | typeof SVG_RESULT;
declare const ATTRIBUTE_PART = 1;
declare const CHILD_PART = 2;
declare const ELEMENT_PART = 6;
declare const COMMENT_PART = 7;
/**
 * The return type of the template tag functions.
 */
export declare type TemplateResult = {
    _$litType$: ResultType;
    strings: TemplateStringsArray;
    values: unknown[];
};
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
export declare const html: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult;
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
export declare const svg: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult;
/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
export declare const noChange: unique symbol;
/**
 * A sentinel value that signals a ChildPart to fully clear its content.
 */
export declare const nothing: unique symbol;
export interface RenderOptions {
    /**
     * An object to use as the `this` value for event listeners. It's often
     * useful to set this to the host component rendering a template.
     */
    host?: EventTarget;
    /**
     * A DOM node before which to render content in the container.
     */
    renderBefore?: ChildNode | null;
}
/**
 * Renders a value, usually a lit-html TemplateResult, to the container.
 * @param value
 * @param container
 * @param options
 */
export declare const render: {
    (value: unknown, container: HTMLElement | DocumentFragment, options?: RenderOptions | undefined): ChildPart;
    setSanitizer: (newSanitizer: SanitizerFactory) => void;
    createSanitizer: SanitizerFactory;
    _testOnlyClearSanitizerFactoryDoNotCallOrElse: () => void;
};
export interface DirectiveParent {
    _$parent?: DirectiveParent;
    __directive?: Directive;
    __directives?: Array<Directive | undefined>;
}
export declare type Template = Interface<TemplateImpl>;
declare class TemplateImpl {
    /** @internal */
    _$element: HTMLTemplateElement;
    /** @internal */
    _parts: Array<TemplatePart>;
    _$options?: RenderOptions;
    constructor({ strings, _$litType$: type }: TemplateResult, options?: RenderOptions);
    _$createElement(html: string): HTMLTemplateElement;
}
export interface Disconnectable {
    _$parent?: Disconnectable;
    _$disconnetableChildren?: Set<Disconnectable>;
}
declare function resolveDirective(part: ChildPart | AttributePart | ElementPart, value: unknown, _$parent?: DirectiveParent, _$attributeIndex?: number): unknown;
/**
 * An updateable instance of a Template. Holds references to the Parts used to
 * update the template instance.
 */
declare class TemplateInstance {
    /** @internal */
    _$template: Template;
    /** @internal */
    _parts: Array<Part | undefined>;
    /** @internal */
    _$parent: Disconnectable;
    /** @internal */
    _$disconnetableChildren?: Set<Disconnectable>;
    constructor(template: Template, parent: ChildPart);
    _clone(options: RenderOptions | undefined): DocumentFragment;
    _update(values: Array<unknown>): void;
}
declare type AttributePartConstructor = {
    new (element: HTMLElement, name: string, strings: ReadonlyArray<string>, parent: Disconnectable | undefined, options: RenderOptions | undefined): AttributePart;
};
declare type AttributeTemplatePart = {
    readonly _type: typeof ATTRIBUTE_PART;
    readonly _index: number;
    readonly _name: string;
    /** @internal */
    readonly _constructor: AttributePartConstructor;
    /** @internal */
    readonly _strings: ReadonlyArray<string>;
};
declare type NodeTemplatePart = {
    readonly _type: typeof CHILD_PART;
    readonly _index: number;
};
declare type ElementTemplatePart = {
    readonly _type: typeof ELEMENT_PART;
    readonly _index: number;
};
declare type CommentTemplatePart = {
    readonly _type: typeof COMMENT_PART;
    readonly _index: number;
};
/**
 * A TemplatePart represents a dynamic part in a template, before the template
 * is instantiated. When a template is instantiated Parts are created from
 * TemplateParts.
 */
declare type TemplatePart = NodeTemplatePart | AttributeTemplatePart | ElementTemplatePart | CommentTemplatePart;
export declare type Part = ChildPart | AttributePart | PropertyPart | BooleanAttributePart | ElementPart | EventPart;
declare type Interface<T> = {
    [P in keyof T]: T[P];
};
export declare type ChildPart = Interface<ChildPartImpl>;
declare class ChildPartImpl {
    readonly type = 2;
    readonly options: RenderOptions | undefined;
    _$committedValue: unknown;
    /** @internal */
    __directive?: Directive;
    /** @internal */
    _$startNode: ChildNode;
    /** @internal */
    _$endNode: ChildNode | null;
    private _textSanitizer;
    /** @internal */
    _$parent: Disconnectable | undefined;
    /** @internal */
    _$disconnetableChildren?: Set<Disconnectable>;
    /** @internal */
    _$setChildPartConnected?(isConnected: boolean, removeFromParent?: boolean, from?: number): void;
    constructor(startNode: ChildNode, endNode: ChildNode | null, parent: TemplateInstance | ChildPart | undefined, options: RenderOptions | undefined);
    /**
     * Sets the connection state for any `DisconnectableDirectives` contained
     * within this part and runs their `disconnectedCallback` or
     * `reconnectedCallback`, according to the `isConnected` argument.
     * @param isConnected
     */
    setConnected(isConnected: boolean): void;
    get parentNode(): Node;
    _$setValue(value: unknown, directiveParent?: DirectiveParent): void;
    private _insert;
    private _commitNode;
    private _commitText;
    private _commitTemplateResult;
    /** @internal */
    _$getTemplate(strings: TemplateStringsArray, result: TemplateResult): Interface<TemplateImpl>;
    private _commitIterable;
    /**
     * Removes the nodes contained within this Part from the DOM.
     *
     * @param start Start node to clear from, for clearing a subset of the part's
     *     DOM (used when truncating iterables)
     * @param from  When `start` is specified, the index within the iterable from
     *     which ChildParts are being removed, used for disconnecting directives in
     *     those Parts.
     *
     * @internal
     */
    _$clear(start?: ChildNode | null, from?: number): void;
}
export declare type AttributePart = Interface<AttributePartImpl>;
declare class AttributePartImpl {
    readonly type: 1 | 5 | 4 | 3;
    readonly element: HTMLElement;
    readonly name: string;
    readonly options: RenderOptions | undefined;
    /**
     * If this attribute part represents an interpolation, this contains the
     * static strings of the interpolation. For single-value, complete bindings,
     * this is undefined.
     */
    readonly strings?: ReadonlyArray<string>;
    /** @internal */
    _$committedValue: unknown | Array<unknown>;
    /** @internal */
    __directives?: Array<Directive | undefined>;
    /** @internal */
    _$parent: Disconnectable | undefined;
    /** @internal */
    _$disconnetableChildren?: Set<Disconnectable>;
    protected _sanitizer: ValueSanitizer | undefined;
    /** @internal */
    _setDirectiveConnected?: (directive: Directive | undefined, isConnected: boolean, removeFromParent?: boolean) => void;
    get tagName(): string;
    constructor(element: HTMLElement, name: string, strings: ReadonlyArray<string>, parent: Disconnectable | undefined, options: RenderOptions | undefined);
    /**
     * Sets the value of this part by resolving the value from possibly multiple
     * values and static strings and committing it to the DOM.
     * If this part is single-valued, `this._strings` will be undefined, and the
     * method will be called with a single value argument. If this part is
     * multi-value, `this._strings` will be defined, and the method is called
     * with the value array of the part's owning TemplateInstance, and an offset
     * into the value array from which the values should be read.
     * This method is overloaded this way to eliminate short-lived array slices
     * of the template instance values, and allow a fast-path for single-valued
     * parts.
     *
     * @param value The part value, or an array of values for multi-valued parts
     * @param valueIndex the index to start reading values from. `undefined` for
     *   single-valued parts
     * @param noCommit causes the part to not commit its value to the DOM. Used
     *   in hydration to prime attribute parts with their first-rendered value,
     *   but not set the attribute, and in SSR to no-op the DOM operation and
     *   capture the value for serialization.
     *
     * @internal
     */
    _$setValue(value: unknown | Array<unknown>, directiveParent?: DirectiveParent, valueIndex?: number, noCommit?: boolean): void;
    /** @internal */
    _commitValue(value: unknown): void;
}
export declare type PropertyPart = Interface<PropertyPartImpl>;
declare class PropertyPartImpl extends AttributePartImpl {
    readonly type = 3;
    /** @internal */
    _commitValue(value: unknown): void;
}
export declare type BooleanAttributePart = Interface<BooleanAttributePartImpl>;
declare class BooleanAttributePartImpl extends AttributePartImpl {
    readonly type = 4;
    /** @internal */
    _commitValue(value: unknown): void;
}
/**
 * An AttributePart that manages an event listener via add/removeEventListener.
 *
 * This part works by adding itself as the event listener on an element, then
 * delegating to the value passed to it. This reduces the number of calls to
 * add/removeEventListener if the listener changes frequently, such as when an
 * inline function is used as a listener.
 *
 * Because event options are passed when adding listeners, we must take case
 * to add and remove the part as a listener when the event options change.
 */
export declare type EventPart = Interface<EventPartImpl>;
declare class EventPartImpl extends AttributePartImpl {
    readonly type = 5;
    /** @internal */
    _$setValue(newListener: unknown, directiveParent?: DirectiveParent): void;
    handleEvent(event: Event): void;
}
export declare type ElementPart = Interface<ElementPartImpl>;
declare class ElementPartImpl {
    element: Element;
    readonly type = 6;
    /** @internal */
    __directive?: Directive;
    _$committedValue: undefined;
    /** @internal */
    _$parent: Disconnectable | undefined;
    /** @internal */
    _$disconnetableChildren?: Set<Disconnectable>;
    /** @internal */
    _setDirectiveConnected?: (directive: Directive | undefined, isConnected: boolean, removeFromParent?: boolean) => void;
    options: RenderOptions | undefined;
    constructor(element: Element, parent: Disconnectable, options: RenderOptions | undefined);
    _$setValue(value: unknown): void;
}
/**
 * END USERS SHOULD NOT RELY ON THIS OBJECT.
 *
 * Private exports for use by other Lit packages, not intended for use by
 * external users.
 *
 * We currently do not make a mangled rollup build of the lit-ssr code. In order
 * to keep a number of (otherwise private) top-level exports  mangled in the
 * client side code, we export a _$private object containing those members (or
 * helper methods for accessing private fields of those members), and then
 * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the
 * client-side code is being used in `dev` mode or `prod` mode.
 *
 * @private
 */
export declare const _$private: {
    _boundAttributeSuffix: string;
    _marker: string;
    _markerMatch: string;
    _HTML_RESULT: number;
    _getTemplateHtml: (strings: TemplateStringsArray, type: ResultType) => [string, string[]];
    _TemplateInstance: typeof TemplateInstance;
    _isIterable: (value: unknown) => value is Iterable<unknown>;
    _resolveDirective: typeof resolveDirective;
    _ChildPart: typeof ChildPartImpl;
    _AttributePart: AttributePartConstructor;
    _BooleanAttributePart: AttributePartConstructor;
    _EventPart: AttributePartConstructor;
    _PropertyPart: AttributePartConstructor;
};
export {};
//# sourceMappingURL=lit-html.d.ts.map