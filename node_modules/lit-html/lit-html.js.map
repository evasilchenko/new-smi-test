{"version":3,"file":"lit-html.js","sources":["src/lit-html.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n// IMPORTANT: these imports must be type-only\nimport {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\n// TODO (justinfagnani): can we get away with `\\s`?\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\0-\\x1F\\x7F-\\x9F \"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n// TODO (justinfagnani): we detect many more parsing edge-cases than we\n// used to, and many of those are of dubious value. Decide and document\n// how to relax correctness to simplify the regexes and states.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult = {\n  _$litType$: ResultType;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = (_$litType$: ResultType) => (\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): TemplateResult => ({\n  _$litType$,\n  strings,\n  values,\n});\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new Map<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: EventTarget;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)._$litPart;\n  if (part === undefined) {\n    const endNode = options?.renderBefore ?? null;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)._$litPart = part = new ChildPartImpl(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [string, string[]] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  const attrNames: Array<string> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) + marker\n        : s + marker + (attrNameEndIndex === -2 ? `:${i}` : '');\n  }\n\n  // Returned as an array for terseness\n  return [\n    // We don't technically need to close the SVG tag since the parser will\n    // handle it for us, but the SSR parser doesn't like that.\n    // Note that the html must end with a node after the final expression to\n    // ensure the last ChildPart has an end node, hence adding a comment if the\n    // last string was empty.\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : ''),\n    attrNames,\n  ];\n};\n\nexport type Template = Interface<TemplateImpl>;\nclass TemplateImpl {\n  /** @internal */\n  _$element!: HTMLTemplateElement;\n  /** @internal */\n  _parts: Array<TemplatePart> = [];\n  // Note, this is used by the `platform-support` module.\n  _$options?: RenderOptions;\n\n  constructor(\n    {strings, _$litType$: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    this._$options = options;\n    let node: Node | null;\n    let nodeIndex = 0;\n    let bindingIndex = 0;\n    let attrNameIndex = 0;\n    const l = strings.length - 1;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this._$element = this._$createElement(html);\n    walker.currentNode = this._$element.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this._$element.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && bindingIndex < l) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (name.endsWith(boundAttributeSuffix)) {\n              const realName = attrNames[attrNameIndex++];\n              // Lowercase for case-sensitive SVG attributes like viewBox\n              const value = (node as Element).getAttribute(\n                realName.toLowerCase() + boundAttributeSuffix\n              )!;\n              attrsToRemove.push(name);\n              const statics = value.split(marker);\n              const m = /([.?@])?(.*)/.exec(realName)!;\n              this._parts.push({\n                _type: ATTRIBUTE_PART,\n                _index: nodeIndex,\n                _name: m[2],\n                _strings: statics,\n                _constructor:\n                  m[1] === '.'\n                    ? PropertyPartImpl\n                    : m[1] === '?'\n                    ? BooleanAttributePartImpl\n                    : m[1] === '@'\n                    ? EventPartImpl\n                    : AttributePartImpl,\n              });\n              bindingIndex += statics.length - 1;\n            } else if (name.startsWith(marker)) {\n              attrsToRemove.push(name);\n              this._parts.push({\n                _type: ELEMENT_PART,\n                _index: nodeIndex,\n              });\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i] || createMarker());\n              this._parts.push({_type: CHILD_PART, _index: ++nodeIndex});\n              bindingIndex++;\n            }\n            (node as Element).append(strings[lastIndex] || createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          bindingIndex++;\n          this._parts.push({_type: CHILD_PART, _index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            this._parts.push({_type: COMMENT_PART, _index: nodeIndex});\n            bindingIndex++;\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  _$createElement(html: string) {\n    const template = d.createElement('template');\n    template.innerHTML = html;\n    return template;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnetableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  _$parent: DirectiveParent = part,\n  _$attributeIndex?: number\n): unknown {\n  let currentDirective =\n    _$attributeIndex !== undefined\n      ? (_$parent as AttributePart).__directives?.[_$attributeIndex]\n      : (_$parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : (value as DirectiveResult)._$litDirective$;\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    currentDirective?._$setDirectiveConnected?.(false);\n    currentDirective =\n      nextDirectiveConstructor === undefined\n        ? undefined\n        : new nextDirectiveConstructor({\n            ...part,\n            _$part: part,\n            _$parent,\n            _$attributeIndex,\n          } as PartInfo);\n    if (_$attributeIndex !== undefined) {\n      ((_$parent as AttributePart).__directives ??= [])[\n        _$attributeIndex\n      ] = currentDirective;\n    } else {\n      (_$parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = currentDirective._resolve((value as DirectiveResult).values);\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      _$element: {content},\n      _parts: parts,\n    } = this._$template;\n    const fragment = d.importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode();\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined && node !== null) {\n      if (nodeIndex === templatePart._index) {\n        let part: Part | undefined;\n        if (templatePart._type === CHILD_PART) {\n          part = new ChildPartImpl(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart._type === ATTRIBUTE_PART) {\n          part = new templatePart._constructor(\n            node as HTMLElement,\n            templatePart._name,\n            templatePart._strings,\n            this,\n            options\n          );\n        } else if (templatePart._type === ELEMENT_PART) {\n          part = new ElementPartImpl(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (templatePart !== undefined && nodeIndex !== templatePart._index) {\n        node = walker.nextNode();\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributePartConstructor = {\n  new (\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ): AttributePart;\n};\ntype AttributeTemplatePart = {\n  readonly _type: typeof ATTRIBUTE_PART;\n  readonly _index: number;\n  readonly _name: string;\n  /** @internal */\n  readonly _constructor: AttributePartConstructor;\n  /** @internal */\n  readonly _strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly _type: typeof CHILD_PART;\n  readonly _index: number;\n};\ntype ElementTemplatePart = {\n  readonly _type: typeof ELEMENT_PART;\n  readonly _index: number;\n};\ntype CommentTemplatePart = {\n  readonly _type: typeof COMMENT_PART;\n  readonly _index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\ntype Interface<T> = {[P in keyof T]: T[P]};\n\nexport type ChildPart = Interface<ChildPartImpl>;\nclass ChildPartImpl {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // DisconnectableDirective\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `DisconnectableDirectives` contained\n   * within this part and runs their `disconnectedCallback` or\n   * `reconnectedCallback`, according to the `isConnected` argument.\n   * @param isConnected\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  get parentNode(): Node {\n    return this._$startNode.parentNode!;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      if (value === nothing) {\n        this._$clear();\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n    } else if ((value as TemplateResult)._$litType$ !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return this._$startNode.parentNode!.insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = this._$startNode.nextSibling;\n    // Make sure undefined and null render as an empty string\n    // TODO: use `nothing` to clear the node?\n    value ??= '';\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? node.nextSibling === null\n        : node === this._$endNode.previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(result: TemplateResult): void {\n    const {values, strings} = result;\n    const template = this._$getTemplate(strings, result);\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template!, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(strings: TemplateStringsArray, result: TemplateResult) {\n    let template = templateCache.get(strings);\n    if (template === undefined) {\n      templateCache.set(strings, (template = new TemplateImpl(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPartImpl[];\n    let partIndex = 0;\n    let itemPart: ChildPartImpl | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/Polymer/lit-html/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPartImpl(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(itemPart?._$endNode!.nextSibling, partIndex);\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = this._$startNode.nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = start!.nextSibling;\n      start!.remove();\n      start = n;\n    }\n  }\n}\n\nexport type AttributePart = Interface<AttributePartImpl>;\nclass AttributePartImpl {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      this.element.removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      this.element.setAttribute(this.name, (value ?? '') as string);\n    }\n  }\n}\n\nexport type PropertyPart = Interface<PropertyPartImpl>;\nclass PropertyPartImpl extends AttributePartImpl {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type BooleanAttributePart = Interface<BooleanAttributePartImpl>;\nclass BooleanAttributePartImpl extends AttributePartImpl {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      this.element.setAttribute(this.name, '');\n    } else {\n      this.element.removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type EventPart = Interface<EventPartImpl>;\nclass EventPartImpl extends AttributePartImpl {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this._$element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type ElementPart = Interface<ElementPartImpl>;\nclass ElementPartImpl {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnetableChildren?: Set<Disconnectable> = undefined;\n\n  /** @internal */\n  _setDirectiveConnected?: (\n    directive: Directive | undefined,\n    isConnected: boolean,\n    removeFromParent?: boolean\n  ) => void = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _$private object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * @private\n */\nexport const _$private = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPartImpl,\n  _AttributePart: AttributePartImpl as AttributePartConstructor,\n  _BooleanAttributePart: BooleanAttributePartImpl as AttributePartConstructor,\n  _EventPart: EventPartImpl as AttributePartConstructor,\n  _PropertyPart: PropertyPartImpl as AttributePartConstructor,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(TemplateImpl, ChildPartImpl);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-pre.5');\n"],"names":["marker","Math","random","String","slice","markerMatch","nodeMarker","d","document","createMarker","v","createComment","isPrimitive","value","isArray","Array","isIterable","Symbol","iterator","textEndRegex","commentEndRegex","comment2EndRegex","tagEndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","rawTextElement","tag","_$litType$","strings","values","html","svg","noChange","for","nothing","templateCache","Map","render","container","options","partOwnerNode","renderBefore","part","_$litPart","undefined","endNode","ChildPartImpl","insertBefore","_$setValue","walker","createTreeWalker","getTemplateHtml","type","l","length","attrNames","rawTextEndRegex","regex","i","s","attrName","match","attrNameEndIndex","lastIndex","exec","test","RegExp","push","TemplateImpl","[object Object]","node","this","_$options","nodeIndex","bindingIndex","attrNameIndex","_$element","_$createElement","currentNode","content","svgElement","firstChild","remove","append","childNodes","nextNode","nodeType","hasAttributes","attrsToRemove","name","getAttributeNames","endsWith","realName","getAttribute","toLowerCase","statics","split","m","_parts","h","u","p","PropertyPartImpl","BooleanAttributePartImpl","EventPartImpl","AttributePartImpl","startsWith","removeAttribute","tagName","textContent","data","indexOf","template","createElement","innerHTML","resolveDirective","_$parent","_$attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","_$litDirective$","constructor","_$setDirectiveConnected","$","P","g","_resolve","TemplateInstance","parent","_$template","B","o","parts","fragment","importNode","partIndex","templatePart","_index","_type","nextSibling","_constructor","_name","_strings","ElementPartImpl","startNode","_$startNode","_$endNode","isConnected","_$setChildPartConnected","parentNode","directiveParent","_$clear","_$committedValue","_commitText","_commitTemplateResult","_commitNode","_commitIterable","ref","_insert","previousSibling","createTextNode","result","_$getTemplate","_update","instance","_clone","get","set","itemParts","itemPart","item","start","from","n","element","fill","valueIndex","noCommit","change","_commitValue","setAttribute","newListener","oldListener","shouldRemoveListener","capture","once","passive","shouldAddListener","removeEventListener","addEventListener","event","call","host","handleEvent","_$private","et","nt","ot","rt","ht","lt","ct","dt","ut","at","ft","vt","wt","globalThis"],"mappings":"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"}