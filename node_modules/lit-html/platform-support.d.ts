/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * lit-html patch to support browsers without native web components.
 *
 * This module should be used in addition to loading the web components
 * polyfills via @webcomponents/webcomponentjs. When using those polyfills
 * support for polyfilled Shadow DOM is automatic via the ShadyDOM polyfill.
 * Scoping classes are added to DOM nodes to facilitate CSS scoping that
 * simulates the style scoping Shadow DOM provides. ShadyDOM does this scoping
 * to all elements added to the DOM. This module provides an important
 * optimization for this process by pre-scoping lit-html template
 * DOM. This means ShadyDOM does not have to scope each instance of the
 * template DOM. Instead, each template is scoped only once.
 *
 * Creating scoped CSS is not covered by this module. It is, however, integrated
 * into the lit-element and @lit/reactive-element packages. See the ShadyCSS docs
 * for how to apply scoping to CSS:
 * https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#usage.
 *
 * @packageDocumentation
 */
declare const needsPlatformSupport: boolean;
interface RenderOptions {
    readonly renderBefore?: ChildNode | null;
    scope?: string;
}
interface ShadyTemplateResult {
    strings: TemplateStringsArray;
    _$litType$?: string;
}
interface PatchableChildPart {
    new (...args: any[]): PatchableChildPart;
    _$committedValue: unknown;
    _$startNode: ChildNode;
    _$endNode: ChildNode | null;
    options: RenderOptions;
    _$setValue(value: unknown): void;
    _$getTemplate(strings: TemplateStringsArray, result: ShadyTemplateResult): HTMLTemplateElement;
}
interface PatchableTemplate {
    new (...args: any[]): PatchableTemplate;
    _$createElement(html: string): HTMLTemplateElement;
    _$element: HTMLTemplateElement;
    _$options: RenderOptions;
}
interface PatchableTemplateInstance {
    _$template: PatchableTemplate;
}
declare const styledScopes: Set<string>;
declare const scopeCssStore: Map<string, string[]>;
//# sourceMappingURL=platform-support.d.ts.map